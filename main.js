const axios = require('axios');
const { version } = require('./package.json');
const fs = require('fs');
const { Console } = require('console');
var v5 = require('uuidv5');

async function register ({
  registerHook,
  registerSetting,
  settingsManager,
  storageManager,
  peertubeHelpers,
  getRouter,
  videoCategoryManager,
  videoLicenceManager,
  videoLanguageManager
}) {
    registerSetting({
    name: 'rss-enable',
    default: true,
    label: 'Enable enhanced Podcasting 2.0 configuration',
    type: 'input-checkbox',
    descriptionHTML: 'This will enable enhances podcasting 2.0 namespace configuration via channel managemnt page',
    private: false
  })
  registerSetting({
    name: 'irc-enable',
    default: false,
    label: 'Enable IRC chat for channels',
    type: 'input-checkbox',
    descriptionHTML: 'This will enable IRC chat for every channel. Channels can customize the autogenerated room if they have a preferred room',
    private: false
  })
    registerSetting({
    name: 'debug-enable',
    default: false,
    label: 'Enable diagnostic log updates',
    type: 'input-checkbox',
    descriptionHTML: 'This will create more extensive logging of program state data both client and server side for finding and resolving errors ',
    private: false
  })
  let enableRss = await settingsManager.getSetting("rss-enable");
  let enableChat = await settingsManager.getSettings("irc-enable");
  let enableDebug = await settingsManager.getSetting("debug-enable");
  var base = await peertubeHelpers.config.getWebserverUrl();
  var serverConfig = await peertubeHelpers.config.getServerConfig();
  var hostName = serverConfig.instance.name;
  console.log("ðŸš§ðŸš§ home url",base,hostName);
  console.log("ðŸš§ðŸš§ðŸš§ðŸš§ Podcast2 plugin started");
  if (enableDebug) {
    console.log("ðŸš§ðŸš§ server settings loaded", hostName, base, serverConfig, enableRss,enableChat);
  }
  registerHook({
    target: 'action:api.video.updated',
    handler: ({ video, body }) => {
      if (enableDebug) {
        console.log("ðŸš§ðŸš§updating video\n",body.pluginData);
      }
      //if (!body.pluginData) return

      const seasonNode = body.pluginData['seasonnode'];
      const seasonName = body.pluginData['seasonname'];
      const episodeNode = body.pluginData['episodenode'];
      const episodeName = body.pluginData['episodename'];
      const chapters = body.pluginData['chapters'];
      const itemTxt = body.pluginData['itemtxt'];

      //if (!value) return
      storageManager.storeData('seasonnode-' + video.id, seasonNode)
      storageManager.storeData('seasonname-' + video.id, seasonName)
      storageManager.storeData('episodenode-' + video.id, episodeNode)
      storageManager.storeData('episodename-' + video.id, episodeName)
      storageManager.storeData('chapters-' + video.id, chapters)
      storageManager.storeData('itemtxt-' + video.id, itemTxt)
      return;
    }
  })
    registerHook({
    target: 'filter:api.video.get.result',
    handler: async (video) => {
      if (!video) return video
      if (!video.pluginData) video.pluginData = {}

      video.pluginData['itemtxt'] = await storageManager.getData('itemtxt' + '-' + video.id)
      video.pluginData['chapters'] = await storageManager.getData('chapters' + '-' + video.id)
      video.pluginData['seasonnode'] = await storageManager.getData('seasonnode' + '-' + video.id)
      video.pluginData['seasonname'] = await storageManager.getData('seasonname' + '-' + video.id)
      video.pluginData['episodenode'] = await storageManager.getData('episodenode' + '-' + video.id)
      video.pluginData['episodename'] = await storageManager.getData('episodename' + '-' + video.id)

      return video
    }
  })
    registerHook({
    target: 'filter:feed.podcast.channel.create-custom-tags.result',
    handler: async (result, params) => {
      const { videoChannel } = params
      console.log("ðŸš§ðŸš§ðŸš§ðŸš§ initial channel values ðŸš§ðŸš§ðŸš§ðŸš§",params,params.videoChannel.dataValues.Actor,params.videoChannel.dataValues.ownerAccount);
      var channel = params.videoChannel.dataValues.Actor.dataValues.preferredUsername;
      var name =    params.videoChannel.dataValues.name;

      let podreturn = [];
      /* currently handled by lightning plugin
      let channelGuid;
      apiUrl = base + "/plugins/podcast2/router/getchannelguid?channel=" + channel;
      try {
        let guidData = await axios.get(apiUrl);
        if (guidData && guidData.data) {
          console.log("ðŸš§ðŸš§channel guid", guidData.data,apiUrl);
          channelGuid = guidData.data;
        }
      } catch {
        console.log("ðŸš§ðŸš§unable to load channel guid", apiUrl);
      }
      if (channelGuid){
        podreturn.push({
          name: "podcast:guid",
          value: channelGuid,
        });
      }
      console.log("ðŸš§ðŸš§unable to load channel guid", apiUrl);
      */
      let podData;
      try {
        podData = await storageManager.getData("pod-" + channel.replace(/\./g, "-"));
        if (enableDebug){
          console.log("ðŸš§ðŸš§ got poddata ", channel,podData);
        }
      } catch (err) {
        console.log("ðŸš§ðŸš§error getting pod data for ", channel);
      }
      if (podData && podData.email.indexOf("@")>0){
        let blocks =[];
        let newBlock = {};
        newBlock.name = "itunes:owner";
        let iname = {};
        iname.name = "itunes:name";
        iname.value = name;
        blocks.push(iname);
        let iemail={};
        iemail.name = "itunes:email";
        iemail.value =podData.email
        blocks.push(iemail);
        podreturn.push({
          name: "itunes:owner",
          value: blocks,
        });
      }
      if (podData && podData.text && podData.text[0] != "") {
        let ptext = {
          name: "podcast:txt",
          value: podData.text[0]
        }
        podreturn.push(ptext);
      }
      if (podData && podData.feedguid && podData.feedguid !="") {
        let fguid = {
          name: "podcast:guid",
          value: podData.feedguid
        }
        podreturn.push(fguid);  
      }
      if (podData && podData.category && podData.category != "") {
        let category={
          name: "itunes:category",
          attributes: {text: "News"}
        }
        podreturn.push(category);
      }
      if (podData && podData.image && podData.image !="") {
        let image={
          name: "itunes:image",
          attributes: {href: "https://www.peppercarrot.com/0_sources/0ther/framasoft/hi-res/2020-05-21_Peertube-Research_by-David-Revoy.jpg"}
        }
        podreturn.push(image);
      }
      let author = {
        name: "itunes:author",
        value: name
      }
      podreturn.push(author);
      let language = {
        name:"language",
        value: "en"
      }
      podreturn.push(language);
  
      return result.concat(podreturn)
    }
  })
  registerHook({
    target: 'filter:feed.podcast.video.create-custom-tags.result',
    handler: async (result, params) => {      const { video, liveItem } = params
      //console.log("ðŸš§ðŸš§ðŸš§ðŸš§ initial video values ðŸš§ðŸš§ðŸš§ðŸš§",result,params,params.video);
      if (liveItem) {
      }
      var videoUuid = params.video.dataValues.uuid;
      //var videoJSON = await peertubeHelpers.videos.loadByIdOrUUID(videoUuid)
      let customObjects = [];
      let captionApi = base + "/api/v1/videos/" + videoUuid + "/captions";
      let captionResult;
      try {
        captionResult = await axios.get(captionApi);
      } catch (err) {
        console.log("ðŸš§ðŸš§failed requesting transcript data", captionApi,err);
      }
      let captionPath, captionLanguage, captionItem;
      //if (captionResult && captionResult.data && captionResult.data.total > 0) {
      //console.log("ðŸš§ðŸš§\ncaption result", captionResult.data);
      for (var captionEntry in captionResult.data.data) {
        captionPath = base + captionEntry.captionPath
        if (captionEntry.language) {
          captionLanguage = captionEntry.language.id;
        }
        if (captionPath.indexOf("vtt") > 1) {
          type = "text/vtt"
        } else {
          type = "text/plain"
          //fixed = fixed + "\n" + spacer + `<podcast:transcript url="` + captionPath + `" language="` + captionLanguage + `" type="text/plain" rel="captions"/>`;
        }
        captionItem = {
          name: "podcast:transcript",
          attributes: {
            "url": captionPath,
            "language": captionLanguage,
            "type": type,
            "rel": "captions"
          }
        };
        customObjects.push(captionItem);
      }
      var apiCall = base + "/api/v1/videos/" + videoUuid;
      let videoData;
      try {
        videoData = await axios.get(apiCall);
      } catch (err){
        console.log("ðŸš§ðŸš§\n\n\n\n\n\nfailed to pull information for provided video id", apiCall,err);
      }
      if (videoData && videoData.data) {
        if (enableDebug){
          console.log("[pod] video data found");
        }
        let duration = videoData.data.duration;
        let customData = videoData.data.pluginData;
        let filename;
        let smallest = 999999999
        if (enableDebug){
          console.log("[pod] streaming playlists",videoData.data.streamingPlaylists);
        }
        if (videoData.data.streamingPlaylists[0]){
          let videoFiles = videoData.data.streamingPlaylists[0].files;
          if (videoFiles) {
            for (var fileOption of videoFiles) {
              console.log("[pod] file options",fileOption);
              if (fileOption.size < smallest) {
                smallest = fileOption.size;
                filename = fileOption.fileUrl
              }
            }
          }
        } else {
          if (enableDebug){
            console.log("[pod] video streaming file data found",videoData.data);
          }
        }
        var enclosure;
        //console.log("\nðŸš§ðŸš§\n\n\nsmallest??",filename,smallest);
        if (filename) {
          enclosure = {
            name: "audioenclosure",
            attributes: {
              "url": filename,
              type: "video/mp4",
              length: duration
            }
          }
        } 
        if (enclosure) {
          customObjects.push(enclosure);
        }
        console.log("ðŸš§ðŸš§\nplugin data", customData);
        
        if (customData && customData.seasonnode){
          let seasonItem = {
            name: "podcast:season",
            value: await customData.seasonnode.toString()
          };
          if (customData.seasonname){
            seasonItem.attributes={
              "name": customData.seasonname
            }
          }
          customObjects.push(seasonItem);
        }
        
        if (customData && customData.episodenode){
          episodeItem = {
            name: "podcast:episode",
            value: await customData.episodenode.toString()
          };
          if (customData.episodename){
            episodeItem.attributes={
              "display": customData.episodename
            }
          }
          customObjects.push(episodeItem);
        }
        
        if (customData && customData.chapters){
          chaptersItem = {
            name: "podcast:chapters",
            attributes: {
              "url": customData.chapters,
              type: "application/json+chapters"
            }
          };
          customObjects.push(chaptersItem);
        }
       
        if (customData && customData.itemtxt){
         // let txtValue=[].push(customData.itemtxt);
          let txtItem = {
            name: "podcast:txt",
            value: customData.itemtxt
          }
          customObjects.push(txtItem);
        }
        
      }
      console.log("custom objects to add to video",customObjects);
      return result.concat(customObjects);
    }
  })
  
  const router = getRouter();

  router.use('/podcast2', async (req, res) => {
    if (enableDebug) {
      console.log("ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ podcast2 request ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§", req.query);
    }
    if (!enableRss) {
      console.log("ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§RSS disabled");
      return res.status(403).send();
    }
    if (req.query.channel == undefined) {
      console.log("ðŸš§ðŸš§no channel requested", req.query);
      return res.status(404).send();
    }
    let podData
    let podApi = base + "/plugins/podcast2/router/getpoddata?channel=" + req.query.channel;
    try {
      podData = await axios.get(podApi);
    } catch {
      console.log("unable to load PODCAST data",req.query.channel,podApi);
    }
    if (podData) {
      console.log("ðŸš§ðŸš§\n\n\n\n pod data \n", podData.data);
      if (podData.data && podData.data.redirectEnabled){
        //return res.redirect(301, podData.data.redirectUrl);
        res.set('location', podData.data.redirectUrl);
        return res.status(301).send()
      }
    }
    let channel = req.query.channel
    let apiUrl = base + "/api/v1/video-channels/" + channel;
    let channelData;
    try {
      channelData = await axios.get(apiUrl);
    } catch {
      console.log("ðŸš§ðŸš§ðŸš§ðŸš§unable to load channel info", apiUrl);
      return res.status(400).send();
    }
    let smallChannelAvatar, largeChannelAvatar, smallPersonAvatar, largePersonAvatar
    if (channelData && channelData.data && channelData.data.avatars && channelData.data.avatars[1]) {
      smallChannelAvatar = channelData.data.avatars[0].path;
      largeChannelAvatar = channelData.data.avatars[1].path;
    }
    if (channelData && channelData.data && channelData.data.ownerAccount && channelData.data.ownerAccount.avatars && channelData.data.ownerAccount.avatars[1]) {
      smallPersonAvatar = channelData.data.ownerAccount.avatars[0].path;
      largePersonAvatar = channelData.data.ownerAccount.avatars[1].path;
    }
    //console.log("ðŸš§ðŸš§ðŸš§ðŸš§channel info", channelData.data);
    
    let rssUrl = base + "/feeds/podcast/videos.xml?videoChannelId=" + channelData.data.id;
    let rssData;
    try {
      rssData = await axios.get(rssUrl)
    } catch {
      console.log("ðŸš§ðŸš§unable to load rss feed for", channel, rssUrl);
      return res.status(400).send();
    }
    //console.log("ðŸš§ðŸš§loaded rss feed from", rssUrl);
    let channelGuid;
    apiUrl = base + "/plugins/podcast2/router/getchannelguid?channel=" + channel;
    try {
      let guidData = await axios.get(apiUrl);
      if (guidData && guidData.data) {
        //console.log("ðŸš§ðŸš§channel guid", guidData.data);
        channelGuid = guidData.data;
      }
    } catch {
      console.log("ðŸš§ðŸš§unable to load channel guid", apiUrl);
    }
    //TODO figure out how to get info for livechat plugin as well

    let counter = 0;
    let fixed = "";
    let spacer = "";
    let rss = rssData.data;
    let lines = rss.split('\n');
      console.log("ðŸš§ðŸš§\n\n\n\n starting linbe loop \n", lines.length,lines[33]);
    //for (const line of lines) {
    let totalSize = lines.length;
    while (counter<totalSize){
      let line = lines[counter];
      //console.log(`ðŸš§line${counter}:`,line)
      counter++;
      spacer = line.split("<")[0];
      if (line.includes("ToraifÅsu") && podData && podData.data) {

       // if (podData.data.text  && podData.data.text[0] != "") {
       //   line = line + `\n${spacer}<podcast:txt>${podData.data.text[0]}</podcast:txt>`;
       // }
       // if (podData.data.feedguid) {
       //   line = line + `\n${spacer}<podcast:guid>${podData.data.feedguid}</podcast:guid>`;
      //  }
      //  if (podData.data.email){
          //line = line + `\n${spacer}<itunes:owner>`;
          //line = line + `\n${spacer}  <itunes:name>${channelData.data.displayName}</itunes:name>`;
          //line = line + `\n${spacer}  <itunes:email>${podData.data.email}</itunes:email>`;
          //line = line + `\n${spacer}</itunes:owner>`;
          //line = line + `\n${spacer}<language>en</language>`;
          //line = line + `\n${spacer}<itunes:category text="News"/>`;
          //line = line + `\n${spacer}<itunes:image href="https://noagendaassets.com/enc/1686340519.979_pcifeedimage.png"/>`;
       // }
      }
      if (line.includes("<atom:link")) {
        line = `${spacer}<atom:link href="https://${req.get('host')}${req.originalUrl}" rel="self" type="application/rss+xml" />`;
        //line = line + `\n${spacer}<itunes:author>${channelData.data.displayName}</itunes:author>`;
      }
      if (line.includes("itunes:explicit")){
        line = line.replace("no","false");
        line = line.replace("yes","true");
      }
      var customData = {};
      if (line.includes('<guid')) {
        let shortUuid = line.split(">")[1].split("<")[0].split("/")[4]
        try {
          var videoData = await axios.get(base + "/api/v1/videos/" + shortUuid);
          if (videoData && videoData.data) {
            customData = videoData.data.pluginData;
          }
        } catch (err) {
          console.log("ðŸš§ðŸš§ðŸš§ðŸš§hard error trying to get video data for RSS feed", err);
        }
        if (enableDebug) {
          console.log("ðŸš§ðŸš§ðŸš§ðŸš§item plugin data", shortUuid, customData);
        }

      }
      if (line.includes("<enclosure") > 0) {
        continue;
      }
      if (line.includes("audioenclosure") > 0) {
        line = line.replace("audioenclosure", "enclosure");
      }
      if (line.includes(`title="HLS"`) && !line.includes(`length="`)) {
        console.log("fixing length");
        line = line.replace(`title="HLS"`, `title="HLS" length ="69"`);
      }
      if (line.includes(`title="HLS"`) && !line.includes(`type="`)) {
        console.log("fixing type");
        line = line.replace(`title="HLS"`, `title="HLS" type="application/x-mpegURL"`);
      }
      if (line.includes(`title="Audio"`) && !line.includes(`type="`)) {
        console.log("fixing type");
        line = line.replace(`title="Audio"`, `title="Audio" type="audio/mp4"`);
      }
      if (largeChannelAvatar) {
        line = line.replace(smallChannelAvatar, largeChannelAvatar);
      }
      if (largePersonAvatar) {
        line = line.replace(smallPersonAvatar, largePersonAvatar);
      }
      if (podData && podData.data && podData.data.medium) {
        line = line.replace(`<podcast:medium>video</podcast:medium>`, `<podcast:medium>${podData.data.medium}</podcast:medium>`);
      }
      if (counter > 1) {
        fixed = fixed + '\n' + line;
      } else {
        fixed = line;
      }
    }
    res.setHeader('content-type', 'application/rss+xml');
    console.log("ðŸš§ðŸš§\n\n\n\n ending line loop \n",fixed.length);
    return  res.status(200).send(fixed);
    
  })
  router.use('/dirtyhack', async (req, res) => {
    console.log("ðŸš§ðŸš§ðŸš§ðŸš§ dirty hack",dirtyHack,req.query);
    if (req.query.cp){
      console.log("ðŸš§ðŸš§ðŸš§ðŸš§ clearing patronage paid days");
      let subscriptions = await storageManager.getData('subscriptions');
      let list = [];
      if (subscriptions){
        for (var sub of subscriptions){
          sub.paiddays=0;
        }
        storageManager.storeData("subscriptions", subscriptions);
        return res.status(200).send(subscriptions);
      }
    }
    doSubscriptions();
    return res.status(200).send(dirtyHack);
  });
  router.use('/getfeedid', async (req, res) => {
    if (enableDebug) {
      console.log("ðŸš§ðŸš§getting feed id", req.query);
    }
    let channel = req.query.channel;
    if (!channel) {
      return res.status(420).send("no channel in feed id request");
    }
    let feed;
    let parts = channel.split('@');
    if (parts.length > 1) {
      let feedApi = "https://" + parts[1] + "/plugins/podcast2/router/getfeedid?channel=" + parts[0];
      try {
        feed = await axios.get(feedApi);
      } catch {
        console.log("ðŸš§ðŸš§hard error getting feed id for ", channel, "from", parts[1], feedApi);
      }
      if (feed && feed.data) {
        //console.log("ðŸš§ðŸš§ returning", feed.data, "for", channel,feed.data.toString());
        return res.status(200).send(feed.data.toString());
      }
      return res.status(420).send("remote channel returned no feed id");
    }
    if (channel) {
      try {
        feed = await storageManager.getData("podcast" + "-" + channel)
      } catch (err) {
        console.log("ðŸš§ðŸš§error getting feedid", channel);
      }
    }
    //console.log("ðŸš§ðŸš§ feed", feed);
    if (feed) {
      return res.status(200).send(feed.toString());
    } else {
      return res.status(400).send("no feed id found for requested channel");
    }
  })
  router.use('/setfeedid', async (req, res) => {
    if (enableDebug) {
      console.log("ðŸš§ðŸš§setting feed id", req.query);
    }
    let channel = req.query.channel;
    let feedID = req.query.feedid;
    if (channel) {
      try {
        await storageManager.storeData("podcast" + "-" + channel, feedID);
        return res.status(200).send();
      } catch (err) {
        console.log("ðŸš§ðŸš§ error storing feedid", channel, feedID);
        return res.status(400).send();
      }
    }
  })
  router.use('/getitemid', async (req, res) => {
    if (enableDebug) {
      console.log("ðŸš§ðŸš§getting item id", req.query);
    }
    let uuid = req.query.uuid;
    let item;
    if (uuid) {
      try {
        item = await storageManager.getData("podcast" + "-" + uuid);
      } catch (err) {
        console.log("ðŸš§ðŸš§ error getting stored itemid", uuid);
      }
    }
    if (item) {
      return res.status(200).send(item.toString());
    } else {
      var apiCall = base + "/api/v1/videos/" + uuid;
      let videoData;
      try {
        videoData = await axios.get(apiCall);
      } catch {
        console.log("ðŸš§ðŸš§failed to pull information for provided video id", apiCall);
      }
      if (videoData) {
        let videoHost = videoData.data.channel.host
        if ("https://" + videoHost != base) {
          let hostApi = "https://" + videoHost + "/plugins/podcast2/router/getitemid?uuid=" + uuid;
          let hostItemId;
          try {
            hostItemId = await axios.get(hostApi);
          } catch {
            console.log("ðŸš§ðŸš§failed to pull item ID from video host", hostApi);
          }
          if (hostItemId) {
            try {
              await storageManager.storeData("podcast" + "-" + uuid, hostItemId);
            } catch {
              console.log("ðŸš§ðŸš§failed to store item ID from host", uuid, hostItemId);
            }
            return res.status(200).send(hostItemId.data.toString());
          } else {
            console.log("ðŸš§ðŸš§ No id provided by hosting instance");
          }
        }
        let channel = videoData.data.channel.name;
        let feedApi = base + "/plugins/podcast2/router/getfeedid?channel=" + channel;
        try {
          feedId = await axios.get(feedApi);
        } catch {
          console.log("ðŸš§ðŸš§ error when tring to get feed id ", feedApi);
          return res.status(404).send();
        }

      }
      console.log("ðŸš§ðŸš§no videodata available", apiCall);
      return res.status(400).send();
    }
  })
  router.use('/setitemid', async (req, res) => {
    if (enableDebug) {
      console.log("ðŸš§ðŸš§setting item id", req.query.uuid);
    }
    let uuid = req.query.uuid;
    let itemID = req.query.itemid;
    if (uuid) {
      try {
        await storageManager.storeData("podcast" + "-" + uuid, itemID);
        return res.sendStatus(200);
      } catch (err) {
        console.log("ðŸš§ðŸš§error setting item id", uuid, itemID);
        return res.sendStatus(400).send();
      }
    }
  })
  router.use('/getchannelguid', async (req, res) => {
    if (enableDebug) {
      console.log("ðŸš§ðŸš§getting channel guid", req.query);
    }
    let host,channelOnly;
    let channel = req.query.channel;
    parts = channel.split("@");
    if (parts.length>1){
      host = parts[1];
      channelOnly = parts[0];
    }
    let channelGuid;
    if (channel) {
      try {
        channelGuid = await storageManager.getData("channelguid" + "-" + channel)
      } catch (err) {
        console.log("ðŸš§ðŸš§ error getting channel guid", channel);
        return res.status(400).send();
      }
    }
    if (!channelGuid && host){
      apiUrl = `https://${host}/plugins/podcast2/router/getchannelguid?channel=${channelOnly}`;
      try {
        console.log("ðŸš§ðŸš§ stuff",base,host,apiUrl);
        let guidData = await axios.get(apiUrl);
        if (guidData && guidData.data) {
          //console.log("ðŸš§ðŸš§channel guid", guidData.data);
          channelGuid = guidData.data;
        }
      } catch {
        console.log("ðŸš§ðŸš§unable to load channel guid", apiUrl);
      }
    }
    if (channelGuid) {
      return res.status(200).send(channelGuid);
    } else {
      //TODO properly create guid
      //let guidResolverUrl = "https://guid.peertube.support/"  
      let rssUrl;
      if (channelOnly){
        rssUrl= await getRss(channelOnly);
      } else {
        rssUrl = await getRss(channel);
      }
      channelGuid = await v5('url',rssUrl);
      if (channelGuid) {
        try {
          await storageManager.storeData("channelguid" + "-" + channel, channelGuid);
        } catch {
          console.log("ðŸš§ðŸš§failed to store channel guid", channel, channelGuid);
        }
        return res.status(200).send(channelGuid);
      } else {
        console.log("ðŸš§ðŸš§ error attempting to generate channel guiid",channel);
        return res.status(400).send();
      }
    }
  })
  router.use('/getpoddata', async (req, res) => {
    if (enableDebug) {
      console.log("ðŸš§ðŸš§getting pod data", req.query);
    }
    let channel = req.query.channel;
    if (!channel) {
      console.log("ðŸš§ðŸš§ no channel in query", channel, req.query);
      return res.status(400).send("ðŸš§ðŸš§ no channel value in request " + req.query);
    }
    let parts = channel.split('@');
    let remotePodData;
    if (parts.length > 1) {
      let remotePodApi = "https://" + parts[1] + "/plugins/podcast2/router/getpoddata?channel=" + parts[0];
      try {
        remotePodData = await axios.get(remotePodApi);
      } catch (err) {
        console.log("ðŸš§ðŸš§hard error getting custom remote pod data for ", channel, "from", parts[1], remotePodApi, err);
        return res.status(400).send("ðŸš§ðŸš§hard error getting custom remote pod data for " + channel + " from " + parts[1] + " using " + remotePodApi + " error " + err);
      }
      if (remotePodData) {
        //console.log("ðŸš§ðŸš§ returning", customChat.toString(), "for", channel);
        return res.status(200).send(remotePodData.data);
      }
      console.log("ðŸš§ðŸš§ no remote pod data found for", channel);
      return res.status(404).send("ðŸš§ðŸš§ no podcast data for " + channel + " on remote system");
    }
    let podData;
    try {
      podData = await storageManager.getData("pod-" + channel.replace(/\./g, "-"));
    } catch (err) {
      console.log("ðŸš§ðŸš§error getting pod data for ", channel);
      return res.status(404).send("ðŸš§ðŸš§ no podcast data for " + req.query.channel + err);
    }
    if (podData) {
      return res.status(200).send(podData);
    } else {
      console.log("ðŸš§ðŸš§ no pod data found for", channel);
      return res.status(404).send("ðŸš§ðŸš§ no pod data found for " + channel);
    }
  })
  router.use('/setpoddata', async (req, res) => {
    if (enableDebug) {
      console.log("ðŸš§ðŸš§setting podcast data", req.query, req.body);
    }
    //TODO verify authorized user is actual owner of room
    let user = await peertubeHelpers.user.getAuthUser(res);
    if (user && user.dataValues && req.body) {
      let userName = user.dataValues.username;
      if (enableDebug) {
        console.log("ðŸš§ðŸš§ðŸš§ got authorized peertube user to set pod data ", user.dataValues.username);
      }
      if (enableDebug) {
        console.log("ðŸš§ðŸš§ðŸš§ðŸš§ user", userName);
      }
      let channel = req.body.channel;
      storageManager.storeData("pod-" + channel.replace(/\./g, "-"), req.body);
      pingPI(channel);
      return res.status(200).send();
    }
    return res.status(420).send();
  })
  async function pingPI(pingChannel) {
    let feedApi = base + "/plugins/podcast2/router/getfeedid?channel=" + pingChannel;
    let feedId;
    try {
      feedId = await axios.get(feedApi);
      let pingResult;
      if (feedId) {
        pingResult = await axios.get("https://api.podcastindex.org/api/1.0/hub/pubnotify?id=" + feedId.data);
      }
      if (pingResult && pingResult.data) {
        return (pingResult.data);
      }
    } catch {
      console.log("ðŸš§ðŸš§hard error when trying ping podcast index ", feedId, feedApi);
    }
  }
  async function getRss(channel){
    let apiUrl = base + "/api/v1/video-channels/" + channel;
    let channelData;
    try {
      channelData = await axios.get(apiUrl);
    } catch {
      console.log("ðŸš§ðŸš§ðŸš§ðŸš§unable to load channel info", apiUrl);
      return ;
    }
    let rssUrl = base + "/feeds/podcast/videos.xml?videoChannelId="+channelData
    return rssUrl;
  }
  async function getConfigPanel(splitInfo, channel) {
    let feedID = await getFeedID(channel);
    if (debugEnabled) {
      console.log("ðŸš§getting config panel", splitInfo, feedID, channel);
    }
    let html = `<br><label _ngcontent-msy-c247="" for="Wallet">Lightning Splits</label><br>`
    if (splitInfo && (keysendEnabled || lnurlEnabled)) {
      if (splitInfo.length > 0) {
        html = html + "<table><th>Split %</th><th><center>Lighting Address</center></th><th>Address Type</th></tr>";
        for (var split in splitInfo) {
          let displayName = splitInfo[split].name;
          if (!displayName) {
            displayName = splitInfo[split].address;
          }
          html = html + "<tr><td>" + splitInfo[split].split + "</td><td>" + displayName + "</td>";
          if (splitInfo[split].keysend) {
            html = html + `<td>Keysend</td>`;
          } else if (splitInfo[split].customKeysend) {
            html = html + `<td>Node</td>`;
          } else if (splitInfo[split].lnurl) {
            html = html + "<td>LNURL Pay</td>";
          } else {
            html = html + "<td>unknown</td>"
          }
          if (!splitInfo[split].fee) {
            html = html + `<td><div class="peertube-button orange-button ng-star-inserted" slot="` + split + `" id="edit-` + split + `">edit</div></td>`;
            //html = html + `<td><button class="peertube-button orange-button ng-star-inserted" >edit</button></td>`;
          }
          html = html + "</tr>";
        }
        html = html + "</table>";
      }
      html = html + `<button type="button" id="add-split" class="peertube-button orange-button ng-star-inserted">Add Split</button>`
    } else {
      html = html + `<button type="button" id="create-split" class="peertube-button orange-button ng-star-inserted">Add Lightning Address</button>`

    }
    if (rssEnabled) {
      html = html + "<hr>"
      html = html + `<button type="button" id="rss-settings" name="ress-settings" class="peertube-button orange-button ng-star-inserted">Podcasting 2.0 RSS settings</button>`;
    }


    html = html + "<hr>"

    //html = html + "<br>podcast 2.0 RSS feed URL: " + rssFeedUrl;
    const panel = document.createElement('div');
    panel.setAttribute('class', 'lightning-button');
    panel.setAttribute('sandbox', 'allow-same-origin allow-scripts allow-popups allow-forms')
    panel.innerHTML = html;
    return panel;
  }
}

async function unregister () {
  return
}

module.exports = {
  register,
  unregister
}
