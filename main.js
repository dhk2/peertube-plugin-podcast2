const axios = require('axios');
const { version } = require('./package.json');
const fs = require('fs');
const { Console } = require('console');
var v5 = require('uuidv5');
let Parser = require('rss-parser');
const FormData = require('form-data');
const imageDataURI = require('image-data-uri');
const { stringify } = require('querystring');
var request = require('request')
const Downloader = require('nodejs-file-downloader');
const YTDlpWrap = require('yt-dlp-wrap').default;
const { parse } = require('rss-to-json');
const { constants } = require('crypto');
const { extract } = require('@extractus/feed-extractor');

async function register ({
  registerHook,
  registerSetting,
  settingsManager,
  storageManager,
  peertubeHelpers,
  getRouter,
  videoCategoryManager,
  videoLicenceManager,
  videoLanguageManager
}) {
    registerSetting({
    name: 'rss-enable',
    default: true,
    label: 'Enable enhanced Podcasting 2.0 configuration',
    type: 'input-checkbox',
    descriptionHTML: 'This will enable enhances podcasting 2.0 namespace configuration via channel managemnt page',
    private: false
  })
  registerSetting({
    name: 'irc-enable',
    default: false,
    label: 'Enable IRC chat for channels',
    type: 'input-checkbox',
    descriptionHTML: 'This will enable IRC chat for every channel. Channels can customize the autogenerated room if they have a preferred room',
    private: false
  })
    registerSetting({
    name: 'debug-enable',
    default: false,
    label: 'Enable diagnostic log updates',
    type: 'input-checkbox',
    descriptionHTML: 'This will create more extensive logging of program state data both client and server side for finding and resolving errors ',
    private: false
  })
  let enableRss = await settingsManager.getSetting("rss-enable");
  let enableChat = await settingsManager.getSettings("irc-enable");
  let enableDebug = await settingsManager.getSetting("debug-enable");
  var base = await peertubeHelpers.config.getWebserverUrl();
  var basePath = peertubeHelpers.plugin.getDataDirectoryPath();
  var serverConfig = await peertubeHelpers.config.getServerConfig();
  var plugins = serverConfig.plugin.registered;
  var hostName = serverConfig.instance.name;
  let hostParts= base.split('//');
  let hostDomain = hostParts.pop();
  const ytDlpWrap = new YTDlpWrap('/var/www/peertube/storage/bin/yt-dlp');
  console.log("ğŸš§ğŸš§ home url",base,hostName);
  console.log("ğŸš§ğŸš§ğŸš§ğŸš§ Podcast2 plugin started");
  if (enableDebug) {
    console.log("ğŸš§ğŸš§ server settings loaded", hostName, base, serverConfig, enableRss,enableChat);
    console.log("ğŸš§ğŸš§ continued", serverConfig.plugin.registered);
  }
  //let Parser = require('rss-parser');
  let dirtyHack;
  let parser = new Parser();
  let podcast2;
  let hiveTube;
  for (var plugin of plugins){
    switch (plugin.npmName){
      case 'peertube-plugin-podcast2' : podcast2=true;
      break;
      case 'peertube-plugin-hive-tube' : hiveTube=true;
      break;
    } 
  }
  registerHook({
    target: 'action:api.video.updated',
    handler: ({ video, body }) => {
      if (enableDebug) {
        console.log("ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ updating video\n",body.pluginData);
      }
      //if (!body.pluginData) return

      const seasonNode = body.pluginData['seasonnode'];
      const seasonName = body.pluginData['seasonname'];
      const episodeNode = body.pluginData['episodenode'];
      const episodeName = body.pluginData['episodename'];
      const chapters = body.pluginData['chapters'];
      const itemTxt = body.pluginData['itemtxt'];
      const sourceId = body.pluginData['sourceid'];
      //if (!value) return
      storageManager.storeData('seasonnode-' + video.id, seasonNode);
      storageManager.storeData('seasonname-' + video.id, seasonName);
      storageManager.storeData('episodenode-' + video.id, episodeNode);
      storageManager.storeData('episodename-' + video.id, episodeName);
      storageManager.storeData('chapters-' + video.id, chapters);
      storageManager.storeData('itemtxt-' + video.id, itemTxt);
      storageManager.storeData('sourceid-' + video.id, sourceId);
      return;
    }
  })
    registerHook({
    target: 'filter:api.video.get.result',
    handler: async (video) => {
      if (!video) return video
      if (!video.pluginData) video.pluginData = {};

      video.pluginData['itemtxt'] = await storageManager.getData('itemtxt' + '-' + video.id);
      video.pluginData['chapters'] = await storageManager.getData('chapters' + '-' + video.id);
      video.pluginData['seasonnode'] = await storageManager.getData('seasonnode' + '-' + video.id);
      video.pluginData['seasonname'] = await storageManager.getData('seasonname' + '-' + video.id);
      video.pluginData['episodenode'] = await storageManager.getData('episodenode' + '-' + video.id);
      video.pluginData['episodename'] = await storageManager.getData('episodename' + '-' + video.id);
      video.pluginData['sourceid'] = await storageManager.getData('sourceid' + '-' +video.id);
      return video;
    }
  })
    registerHook({
    target: 'filter:feed.podcast.channel.create-custom-tags.result',
    handler: async (result, params) => {
      const { videoChannel } = params
      //console.log("ğŸš§ğŸš§ğŸš§ğŸš§ initial channel values ğŸš§ğŸš§ğŸš§ğŸš§",params,params.videoChannel.dataValues.Actor,params.videoChannel.dataValues.ownerAccount);
      var channel = params.videoChannel.dataValues.Actor.dataValues.preferredUsername;
      var name =    params.videoChannel.dataValues.name;

      let podreturn = [];
      let channelGuid;
      apiUrl = base + "/plugins/podcast2/router/getchannelguid?channel=" + channel;
      try {
        let guidData = await axios.get(apiUrl);
        if (guidData && guidData.data) {
          console.log("ğŸš§ğŸš§channel guid", guidData.data,apiUrl);
          channelGuid = guidData.data;
        }
      } catch (err) {
        console.log("ğŸš§ğŸš§ hard error getting channel guid", apiUrl,err);
      }
      /*
      if (channelGuid){
        podreturn.push({
          name: "podcast:guid",
          value: channelGuid,
        });
      }
      */
      let podData;
      try {
        podData = await storageManager.getData("pod-" + channel.replace(/\./g, "-"));
        if (enableDebug){
          console.log("ğŸš§ğŸš§ got poddata ", channel,podData);
        }
      } catch (err) {
        console.log("ğŸš§ğŸš§error getting pod data for ", channel);
      }
      if (podData && podData.email.indexOf("@")>0){
        let blocks =[];
        let newBlock = {};
        newBlock.name = "itunes:owner";
        let iname = {};
        iname.name = "itunes:name";
        iname.value = name;
        blocks.push(iname);
        let iemail={};
        iemail.name = "itunes:email";
        iemail.value =podData.email
        blocks.push(iemail);
        podreturn.push({
          name: "itunes:owner",
          value: blocks,
        });
      }
      if (podData && podData.text && podData.text[0] != "") {
        let ptext = {
          name: "podcast:txt",
          value: podData.text[0]
        }
        podreturn.push(ptext);
      }
      if (podData && podData.feedguid && podData.feedguid !=""){ 
        channelGuid= podData.feedguid;
      }
      if (channelGuid && channelGuid !='' && !hiveTube){
        let fguid = {
          name: "podcast:guid",
          value: channelGuid
        }
        podreturn.push(fguid);  
      }
      if (podData && podData.category && podData.category != "") {
        let category={
          name: "itunes:category",
          attributes: {text: podData.category}
        }
        podreturn.push(category);
      }
      if (podData && podData.image && podData.image !="") {
        let image={
          name: "itunes:image",
          attributes: {href: podData.image},
        }
        podreturn.push(image);
      }
      let author = {
        name: "itunes:author",
        value: name
      }
      podreturn.push(author);
      let language = {
        name:"language",
        value: "en"
      }
      podreturn.push(language);
      return result.concat(podreturn)
    }
  })
  registerHook({
    target: 'filter:feed.podcast.video.create-custom-tags.result',
    handler: async (result, params) => {      const { video, liveItem } = params
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§ initial video values ğŸš§ğŸš§ğŸš§ğŸš§",result,params);
      if (liveItem) {
      }
      var videoUuid = params.video.dataValues.uuid;
      //var videoJSON = await peertubeHelpers.videos.loadByIdOrUUID(videoUuid)
      let customObjects = [];
      let captionApi = base + "/api/v1/videos/" + videoUuid + "/captions";
      let captionResult;
      let rssData =[];
      try {
        captionResult = await axios.get(captionApi);
      } catch (err) {
        console.log("ğŸš§ğŸš§failed requesting transcript data", captionApi,err);
      }
      let captionPath, captionLanguage, captionItem;
      //if (captionResult && captionResult.data && captionResult.data.total > 0) {
      //console.log("ğŸš§ğŸš§\ncaption result", captionResult.data);
      for (var captionEntry in captionResult.data.data) {
        captionPath = base + captionEntry.captionPath
        if (captionEntry.language) {
          captionLanguage = captionEntry.language.id;
        }
        if (captionPath.indexOf("vtt") > 1) {
          type = "text/vtt"
        } else {
          type = "text/plain"
          //fixed = fixed + "\n" + spacer + `<podcast:transcript url="` + captionPath + `" language="` + captionLanguage + `" type="text/plain" rel="captions"/>`;
        }
        captionItem = {
          name: "podcast:transcript",
          attributes: {
            "uri": captionPath,
            "language": captionLanguage,
            "type": type,
            "rel": "captions"
          }
        };
        customObjects.push(captionItem);
      }
      var apiCall = base + "/api/v1/videos/" + videoUuid;
      let videoData;
      try {
        videoData = await axios.get(apiCall);
      } catch (err){
        console.log("ğŸš§ğŸš§\n\n\n\n\n\nfailed to pull information for provided video id", apiCall,err);
      }
      if (videoData && videoData.data) {
        if (enableDebug){
          console.log("[pod] video data found");
        }
        let embedPath = base+videoData.data.embedPath;
        let duration = videoData.data.duration;
        let customData = videoData.data.pluginData;
        let filename,videoFilename;
        let smallest = 999999999;
        let largest = 1;
        if (enableDebug){
          console.log("[pod] streaming playlists",videoData.data.streamingPlaylists);
        }
        if (embedPath){
          let embedEnclosure = {
            name: "podcast:embedEnclosure",
            type: "application/x-mpegURL",
            length: duration,
            title: "PeerTube",
            url: embedPath,
          }
          rssData.push(embedEnclosure)
        }
        if (videoData.data.streamingPlaylists[0]){
          let videoFiles = videoData.data.streamingPlaylists[0].files;
          if (videoFiles) {
            for (var fileOption of videoFiles) {
              console.log("[pod] file options",fileOption);
              if (fileOption.size < smallest) {
                smallest = fileOption.size;
                filename = fileOption.fileUrl
              }
              if (fileOption.size > largest) {
                largest = fileOption.size;
                videoFilename = fileOption.fileUrl
              }
            }
          }
        } else {
          if (enableDebug){
            console.log("[pod] video streaming file data found",videoData.data);
          }
        }
        var enclosure,videoEnclosure;
        var enclosureType;
        //console.log("\nğŸš§ğŸš§\n\n\nsmallest??",filename,smallest);
        if (filename) {
          enclosureType = "video/mp4";
          if (filename.includes("-0-")){
            enclosureType="audio/mp4";
          }
          enclosure = {
            name: "audio",
            url: filename,
            type: enclosureType,
            length: duration
          }
        } 
        if (videoFilename) {
          enclosureType = "video/mp4";
          videoEnclosure = {
            name: "video",
            url: filename,
            type: enclosureType,
            length: duration
          }
        } 
        if (enclosure) {
          //customObjects.push(enclosure);
          rssData.push(enclosure)
        }
        if (videoEnclosure) {
          //customObjects.push(videoEnclosure);
          rssData.push(videoEnclosure)
        }
        console.log("ğŸš§ğŸš§\nplugin data", customData);
        
        if (customData && customData.seasonnode){
          let seasonItem = {
            name: "podcast:season",
            value: await customData.seasonnode.toString()
          };
          if (customData.seasonname){
            seasonItem.attributes={
              "name": customData.seasonname
            }
          }
          customObjects.push(seasonItem);
          let itunesSeason = {
            name: "itunes:season",
            value: customData.seasonnode
          }
          customObjects.push(itunesSeason);
        }
        if (customData && customData.episodenode){
          let episodeItem = {
            name: "podcast:episode",
            value: await customData.episodenode.toString()
          };
          if (customData.episodename){
            episodeItem.attributes={
              "display": customData.episodename
            }
          }
          customObjects.push(episodeItem);
          let itunesEpisode = {
            name: "itunes:episode",
            value: customData.episodenode
          }
          customObjects.push(itunesEpisode)
        }
        if (customData && customData.chapters){
          chaptersItem = {
            name: "podcast:chapters",
            attributes: {
              "url": customData.chapters,
              type: "application/json+chapters"
            }
          };
          customObjects.push(chaptersItem);
        } else {
          chaptersItem = {
            name: "podcast:chapters",
            attributes: {
              "url": `${base}/plugins/podcast2/router/chapters?video=${videoUuid}`,
              type: "application/json+chapters"
            }
          };
          customObjects.push(chaptersItem);          
        }
        if (customData && customData.itemtxt){
         // let txtValue=[].push(customData.itemtxt);
          let txtItem = {
            name: "podcast:txt",
            value: customData.itemtxt
          }
          customObjects.push(txtItem);
        }
        if (customData && customData.sourceid){
          let sourceEnclosure = {
            name: "podcast:ytEnclosure",
            type: "application/x-mpegURL",
            length: duration,
            title: "YouTube",
            url: `https://www.youtube.com/embed/${customData.sourceid}`
          }
          rssData.push(sourceEnclosure)
        }
      }
      console.log("custom objects to add to video",customObjects);
      console.log("results",result);
      console.log("cmbined",result.concat(customObjects));
      await storageManager.storeData('rssvideodata-'+videoUuid,rssData);
      return result.concat(customObjects);
      
    }
  })
  
  const router = getRouter();
  router.use('/rss', async (req, res) => {
    if (enableDebug) {
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ podcast2 rss request ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§", req.query);
    }
    if (!enableRss) {
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§RSS disabled");
      return res.status(403).send();
    }
    if (req.query.channel == undefined) {
      console.log("ğŸš§ğŸš§no channel requested", req.query);
      return res.status(404).send();
    }
    let podData
    let podApi = base + "/plugins/podcast2/router/getpoddata?channel=" + req.query.channel;
    try {
      podData = await axios.get(podApi);
    } catch {
      console.log("unable to load PODCAST data",req.query.channel,podApi);
    }
    if (podData) {
      console.log("ğŸš§ğŸš§\n\n\n\n pod data \n", podData.data);
      if (podData.data && podData.data.redirectEnabled){
        //return res.redirect(301, podData.data.redirectUrl);
        res.set('location', podData.data.redirectUrl);
        return res.status(301).send()
      }
    }
    let channel = req.query.channel
    let apiUrl = base + "/api/v1/video-channels/" + channel;
    let channelData;
    try {
      channelData = await axios.get(apiUrl);
    } catch {
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§unable to load channel info", apiUrl);
      return res.status(400).send();  
    }
    let smallChannelAvatar, largeChannelAvatar, smallPersonAvatar, largePersonAvatar
    if (channelData && channelData.data && channelData.data.avatars && channelData.data.avatars[1]) {
      smallChannelAvatar = channelData.data.avatars[0].path;
      largeChannelAvatar = channelData.data.avatars[1].path;
    }
    if (channelData && channelData.data && channelData.data.ownerAccount && channelData.data.ownerAccount.avatars && channelData.data.ownerAccount.avatars[1]) {
      smallPersonAvatar = channelData.data.ownerAccount.avatars[0].path;
      largePersonAvatar = channelData.data.ownerAccount.avatars[1].path;
    }
    console.log("ğŸš§ğŸš§ğŸš§ğŸš§channel info", channelData.data);
    
    let rssUrl = base + "/feeds/podcast/videos.xml?videoChannelId=" + channelData.data.id;
    let rssData;
    try {
      rssData = await axios.get(rssUrl)
    } catch {
      console.log("ğŸš§ğŸš§unable to load rss feed for", channel, rssUrl);
      return res.status(400).send();
    }
    try{
    var rssJson = await extract(rssUrl, {normalization:false });
    } catch (err) {
      console.log("ğŸš§ğŸš§error loading rss", rssUrl,err);
    }
    console.log(JSON.stringify(rssJson, null, 3));
    return res.status(200).send(rssJson); 
  })
  router.use (`/chapters`, async (req,res) => {
    if (enableDebug) {
      console.log("ğŸš§ğŸš§ chapters request", req.query);
    }
    let videoId;
    if (req.query.video){
      videoId = req.query.video      
    } else {
      console.log("ğŸš§ğŸš§ no video in request", req.query);
      return res.status(420).send("no video");
    }
    let chapterApi = `${base}/api/v1/videos/${videoId}/chapters`
    let chapterData;
    try {
      chapterData = await axios.get(chapterApi);
    } catch (err) {
      console.log("ğŸš§ğŸš§ hard error getting chapters", chapterApi, err);
    }
    let chapters
    if (chapterData){
      chapters = chapterData.data
      if (chapters){
        for (var chapter of chapters.chapters){
          chapter.startTime=chapter.timecode;
          delete chapter.timecode;
        }
      }
      console.log("ğŸš§ğŸš§ chapters ", chapters,chapterData);

    } 
    return res.status(200).send(chapters);
  })
  router.use('/torrent', async (req,res) =>{
    if (enableDebug) {
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§ torrent feed request",req.query);
    }
    if (!enableRss) {
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§RSS disabled");
      return res.status(403).send();
    }
    let channel;
    if (req.query.channel == undefined) {
      console.log("ğŸš§ğŸš§no channel requested", req.query);
      return res.status(404).send();
    } else {
      channel = req.query.channel;
    }
    let podData
    let podApi = base + "/plugins/podcast2/router/getpoddata?channel=" + req.query.channel;
    try {
      podData = await axios.get(podApi);
    } catch {
      console.log("unable to load PODCAST data",req.query.channel,podApi);
    }
    let audio;
    if (podData) {
      console.log("ğŸš§ğŸš§\n\n\n\n pod data \n", podData.data);
      if (podData.data && podData.data.medium){
        if (podData.data.medium == 'audiobook' || podData.data.medium == 'music' || podData.data.medium == 'podcast'){
          audio=true;
        }
      }
    }
    let apiUrl = base + "/api/v1/video-channels/" + channel;
    let channelData;
    try {
      channelData = await axios.get(apiUrl);
    } catch {
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§unable to load channel info", apiUrl);
      return res.status(400).send();
    }
    if (enableDebug) {
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§ channel Data",channelData.data);
    }
    apiUrl = `${base}/api/v1/video-channels/${channel}/videos`;
    let videoData;
    try {
      videoData = await axios.get(apiUrl);
    } catch {
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§unable to load video  info", apiUrl);
      return res.status(400).send();
    }
    if (enableDebug) {
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§ video Data",videoData.data);
    }
    if (videoData && videoData.data ){
      videoList = videoData.data.data;
    } else {
      videoList = [];
    }
    if (enableDebug) {
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§ video list",videoList);
    }
    let rss = `<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">`;
    let indent =4;
    rss = rss +"\n"+' '.repeat(indent)+`<channel>`;
    indent = indent+4;
    rss = rss + `\n`+' '.repeat(indent)+`<title>${channelData.data.displayName.replace(/\W+/g, " ")}</title>`;
    rss = rss + `\n`+' '.repeat(indent)+`<link>${channelData.data.url}</link>`;
    if (channelData.data.description){
      rss = rss + `\n`+' '.repeat(indent)+`<description> ${channelData.data.description.replace(/\W+/g, " ")} </description>`;
    } else {
      rss = rss + `\n`+' '.repeat(indent)+`<description> indescribable </description>`;
    }
    let atomLink = base + "/plugins/podcast2/router/torrent?channel=" + channel;
    rss = rss + `\n`+' '.repeat(indent)+`<atom:link href="${atomLink}" rel="self" type="application/rss+xml" />`;
    for (var video of videoList){
      rss = rss + `\n`+' '.repeat(indent)+`<item>`;
      indent = indent + 4;
      rss = rss + `\n`+' '.repeat(indent)+`<title>${video.name.replace(/\W+/g, " ")}</title>`;
      
      if (video.description){
        rss = rss + `\n`+' '.repeat(indent)+`<description>`;
        indent=indent+4;
        rss = rss + `\n`+' '.repeat(indent)+`${video.description.replace(/\W+/g, " ")}`;
        indent=indent-4;
        rss = rss + `\n`+' '.repeat(indent)+`</description>`;
      } else {
        rss = rss + `\n`+' '.repeat(indent)+`<description/>`;
      }
      
      let apiUrl = `${base}/api/v1/videos/${video.uuid}`;
      let videoSpecificData;
      let torrentUrl, fileSize, magnet, tracker, pubDate,rawDate;
      try {
        videoSpecificData = await axios.get(apiUrl);
      } catch (err) {
        console.log("ğŸš§ğŸš§ğŸš§ğŸš§unable to load video specific info", apiUrl,err);
        return res.status(400).send();
      }
      if (enableDebug) {
        let v;
        v = videoSpecificData.data;
        console.log("ğŸš§ğŸš§ğŸš§ğŸš§ video specific data",v,v.files,v.streamingPlaylists[0],v.streamingPlaylists[0].files);
      }
      
      torrentUrl = videoSpecificData.data.streamingPlaylists[0].files[0].torrentUrl;
      fileSize =   videoSpecificData.data.streamingPlaylists[0].files[0].size;
      magnet = videoSpecificData.data.streamingPlaylists[0].files[0].magnetUri;
      tracker = videoSpecificData.data.trackerUrls[0];
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§ published", pubDate);
      let fileName = video.name;
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§ found file name", fileName);
      rss = rss + `\n`+' '.repeat(indent)+`<enclosure type="application/x-bittorrent" url="${torrentUrl}" length="${fileSize}" />`;
      rss = rss + `\n`+' '.repeat(indent)+`<link>${torrentUrl}</link>`;
      rss = rss + `\n`+' '.repeat(indent)+`<guid>${torrentUrl}</guid>`;
      //rss = rss + `\n`+' '.repeat(indent)+`<media:content url="${torrentUrl}" fileSize="${fileSize}" />`;
      if (videoSpecificData.data.originallyPublishedAt){
        rawDate = videoSpecificData.data.originallyPublishedAt;
      } else {
        rawDate = videoSpecificData.data.publishedAt;
      }
        let newDate = new Date(rawDate);
      pubDate = newDate.toUTCString();

      console.log("ğŸš§ğŸš§ğŸš§ğŸš§ published", rawDate, "new format",newDate, "final format",pubDate);
      rss = rss + `\n`+' '.repeat(indent)+`<pubDate> ${pubDate} </pubDate>`;
      
      /*
      rss = rss + `\n`+' '.repeat(indent)+`<torrent>`;
      indent=indent +4;
      rss = rss + `\n`+' '.repeat(indent)+`<filename> ${fileName} </filename>`;
      rss = rss + `\n`+' '.repeat(indent)+`<contentlength> ${fileSize} </contentlength>`;
      rss = rss + `\n`+' '.repeat(indent)+`<magneturi> ${magnet} <magneturi>`;
      rss = rss + `\n`+' '.repeat(indent)+`<trackers>`;
      indent = indent +4;
      rss = rss + `\n`+' '.repeat(indent)+`<group order="ordered">`;
      indent = indent+4;
      rss = rss + `\n`+' '.repeat(indent)+`<tracker seeds="1" peers="1">`;
      indent = indent + 4;
      rss = rss + `\n`+' '.repeat(indent)+tracker;
      indent = indent - 4
      rss = rss + `\n`+' '.repeat(indent)+`</tracker>`;
      indent = indent -4;
      rss = rss + `\n`+' '.repeat(indent)+`</group>`;
      indent = indent - 4
      rss = rss + `\n`+' '.repeat(indent)+`</trackers>`;
      indent = indent -4;
      rss = rss + `\n`+' '.repeat(indent)+`</torrent>`;
      */
      indent = indent -4;
      
      rss = rss + `\n`+' '.repeat(indent)+`</item>`;
    }
    indent = indent-4;
    rss = rss + `\n`+' '.repeat(indent)+`</channel>`;
    rss = rss + `\n</rss>\n`;
    res.setHeader('content-type', 'application/rss+xml');
    return  res.status(200).send(rss);
  })
  router.use('/podcast2', async (req, res) => {
    if (enableDebug) {
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ podcast2 request ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§", req.query);
    }
    if (!enableRss) {
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§ğŸš§RSS disabled");
      return res.status(403).send();
    }
    if (req.query.channel == undefined) {
      console.log("ğŸš§ğŸš§no channel requested", req.query);
      return res.status(404).send();
    }
    let extendedRssData;
    let forceVideo,forceAudio;
    if (req.query.video){
      forceVideo=true;
    }
    if (req.query.audio){
      forceAudio = true;
    }
    let podData;
    let podApi = base + "/plugins/podcast2/router/getpoddata?channel=" + req.query.channel;
    try {
      podData = await axios.get(podApi);
    } catch {
      console.log("unable to load PODCAST data",req.query.channel,podApi);
    }
    if (podData) {
      console.log("ğŸš§ğŸš§\n\n\n\n pod data \n", podData.data);
      if (podData.data && podData.data.redirectEnabled){
        //return res.redirect(301, podData.data.redirectUrl);
        res.set('location', podData.data.redirectUrl);
        return res.status(301).send()
      }
      let med;
      if (podData.data){
        med = podData.data.medium;
      }
      if (med == "audiobook" || med == "podcast" || med == "music"){
        forceAudio=true;
      }
      if (req.query.video){
        forceVideo=true;
      }
      if (req.query.audio){
        forceAudio = true;
      }
      //hack for now 
      if (!forceAudio){
        forceVideo = true;
      }
    }
    let channel = req.query.channel
    let apiUrl = base + "/api/v1/video-channels/" + channel;
    let channelData;
    try {
      channelData = await axios.get(apiUrl);
    } catch {
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§unable to load channel info", apiUrl);
      return res.status(400).send();
    }
    let smallChannelAvatar, largeChannelAvatar, smallPersonAvatar, largePersonAvatar
    if (channelData && channelData.data && channelData.data.avatars && channelData.data.avatars[1]) {
      smallChannelAvatar = channelData.data.avatars[0].path;
      largeChannelAvatar = channelData.data.avatars[1].path;
    }
    if (channelData && channelData.data && channelData.data.ownerAccount && channelData.data.ownerAccount.avatars && channelData.data.ownerAccount.avatars[1]) {
      smallPersonAvatar = channelData.data.ownerAccount.avatars[0].path;
      largePersonAvatar = channelData.data.ownerAccount.avatars[1].path;
    }
    //console.log("ğŸš§ğŸš§ğŸš§ğŸš§channel info", channelData.data);
    
    let rssUrl = base + "/feeds/podcast/videos.xml?videoChannelId=" + channelData.data.id;
    let rssData;
    try {
      rssData = await axios.get(rssUrl)
    } catch {
      console.log("ğŸš§ğŸš§unable to load rss feed for", channel, rssUrl);
      return res.status(400).send();
    }
    //console.log("ğŸš§ğŸš§loaded rss feed from", rssUrl);
    let channelGuid;
    apiUrl = base + "/plugins/podcast2/router/getchannelguid?channel=" + channel;
    try {
      let guidData = await axios.get(apiUrl);
      if (guidData && guidData.data) {
        console.log("ğŸš§ğŸš§channel guid", guidData.data);
        channelGuid = guidData.data;
      }
    } catch {
      console.log("ğŸš§ğŸš§unable to load channel guid from podcast2", apiUrl);
    }
    if (!channelGuid){
      apiUrl = base + "/plugins/lighting/router/getchannelguid?channel=" + channel;
      try {
        let guidData = await axios.get(apiUrl);
        if (guidData && guidData.data) {
          console.log("ğŸš§ğŸš§channel guid", guidData.data);
          channelGuid = guidData.data;
        }
      } catch {
        console.log("ğŸš§ğŸš§unable to load channel guid from lightning", apiUrl);
      }
    }
    //TODO figure out how to get info for livechat plugin as well

    let counter = 0;
    let fixed = "";
    let spacer = "";
    let rss = rssData.data;
    let lines = rss.split('\n');
      console.log("ğŸš§ğŸš§\n\n\n\n starting linbe loop \n", lines.length,lines[33]);
    //for (const line of lines) {
    let totalSize = lines.length;
    while (counter<totalSize){
      let line = lines[counter];
      //console.log(`ğŸš§line${counter}:`,line)
      counter++;
      spacer = line.split("<")[0];
      if (line.includes("ToraifÅsu") && podData && podData.data) {

       // if (podData.data.text  && podData.data.text[0] != "") {
       //   line = line + `\n${spacer}<podcast:txt>${podData.data.text[0]}</podcast:txt>`;
       // }
       // if (podData.data.feedguid) {
       //   line = line + `\n${spacer}<podcast:guid>${podData.data.feedguid}</podcast:guid>`;
      //  }
      //  if (podData.data.email){
          //line = line + `\n${spacer}<itunes:owner>`;
          //line = line + `\n${spacer}  <itunes:name>${channelData.data.displayName}</itunes:name>`;
          //line = line + `\n${spacer}  <itunes:email>${podData.data.email}</itunes:email>`;
          //line = line + `\n${spacer}</itunes:owner>`;
          //line = line + `\n${spacer}<language>en</language>`;
          //line = line + `\n${spacer}<itunes:category text="News"/>`;
          //line = line + `\n${spacer}<itunes:image href="https://noagendaassets.com/enc/1686340519.979_pcifeedimage.png"/>`;
       // }
      }
      if (line.includes("<atom:link")) {
        line = `${spacer}<atom:link href="https://${req.get('host')}${req.originalUrl}" rel="self" type="application/rss+xml" />`;
        //line = line + `\n${spacer}<itunes:author>${channelData.data.displayName}</itunes:author>`;
      }
      if (line.includes("itunes:explicit")){
        line = line.replace("no","false");
        line = line.replace("yes","true");
      }
      var customData = {};
      if (line.includes('<guid')) {
        let shortUuid = line.split(">")[1].split("<")[0].split("/")[4]
        try {
          var videoData = await axios.get(base + "/api/v1/videos/" + shortUuid);
          if (videoData && videoData.data) {
            customData = videoData.data.pluginData;
          }
        } catch (err) {
          console.log("ğŸš§ğŸš§ğŸš§ğŸš§hard error trying to get video data for RSS feed", err);
        }
        if (enableDebug) {
          //console.log("ğŸš§ğŸš§ğŸš§ğŸš§item plugin data", shortUuid, customData);
        }

      }
      if (line.includes("<enclosure") > 0) {
        var spot = line.indexOf("hls/");
        var uuid = line.substring(spot+4,  spot+40);
        console.log("ğŸš§ğŸš§ğŸš§ğŸš§enclosure",spot, "cut",">"+uuid+"<");
        var extended = await storageManager.getData('rssvideodata-'+uuid);
        console.log("Extended",extended);
        for (file of extended){
          console.log("ğŸš§ğŸš§ğŸš§ğŸš§first pass",file);
          if (file.name == 'audio' && forceAudio){
            line = `\n${spacer}<enclosure url="${file.url}" type="${file.type}" length="${file.length}"/>`
          } else if (file.name == 'video' && forceVideo) {
            line = `\n${spacer}<enclosure url="${file.url}" type="${file.type}" length="${file.length}"/>`
          } 
        }  
        for (file of extended){
          console.log("ğŸš§ğŸš§ğŸš§ğŸš§second pass",file);
          if (file.name != 'audio' && file.name !='video'){
            line = line + `\n${spacer}<podcast:alternateEnclosure type="${file.type}" length="${file.length}" title="${file.title}">`
            line = line + `\n${spacer}  <podcast:source uri="${file.url}"/>`
            line = line + `\n${spacer}</podcast:alternateEnclosure>`
          }
        }
      }
      if (line.includes(`title="HLS"`) && !line.includes(`length="`)) {
        console.log("fixing length");
        line = line.replace(`title="HLS"`, `title="HLS" length ="69"`);
      }
      /* fixed with storage manager fix
      if (line.includes("embedEnclosure") > 0) {
        line = line.replace("embedEnclosure", "alternateEnclosure");
      }
      if (line.includes("ytEnclosure") > 0) {
        line = line.replace("ytEnclosure", "alternateEnclosure");
      }

      if (line.includes(`title="HLS"`) && !line.includes(`type="`)) {
        console.log("fixing type");
        line = line.replace(`title="HLS"`, `title="HLS" type="application/x-mpegURL"`);
      }
      if (line.includes(`title="Audio"`) && !line.includes(`type="`)) {
        console.log("fixing type");
        line = line.replace(`title="Audio"`, `title="Audio" type="audio/mp4"`);
      }
      */
      if (largeChannelAvatar) {
        line = line.replace(smallChannelAvatar, largeChannelAvatar);
      }
      if (largePersonAvatar) {
        line = line.replace(smallPersonAvatar, largePersonAvatar);
      }
      if (podData && podData.data && podData.data.medium) {
        line = line.replace(`<podcast:medium>video</podcast:medium>`, `<podcast:medium>${podData.data.medium}</podcast:medium>`);
        if (podData.data.medium == 'audio-book'){
          line = line + `\n${spacer}<itunes:type>serial</itunes:type>`;
        }
      }
      if (counter > 1) {
        fixed = fixed + '\n' + line;
      } else {
        fixed = line;
      }
    }
    res.setHeader('content-type', 'application/rss+xml');
    console.log("ğŸš§ğŸš§\n\n\n\n ending line loop \n",fixed.length);
    return  res.status(200).send(fixed);
    
  })
  router.use('/dirtyhack', async (req, res) => {
    console.log("ğŸš§ğŸš§ğŸš§ğŸš§ dirty hack",req.query,req.body);
    /*
    if (req.query.cp){
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§ clearing patronage paid days");
      let subscriptions = await storageManager.getData('subscriptions');
      let list = [];
      if (subscriptions){
        for (var sub of subscriptions){
          sub.paiddays=0;
        }
        storageManager.storeData("subscriptions", subscriptions);
        return res.status(200).send(subscriptions);
      }
    }
    */
    let feed;
    if (req.query.avatar){
      let result = updateChannelAvatar(req.query.avatar,'15',req.body.bear);
    }
    if (req.query.youtube){
      let metadata = await ytDlpWrap.getVideoInfo(req.query.youtube);
      console.log(metadata.title);
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§ dirty hack::",metadata);
      return res.status(200).send(metadata);
      
    }
    //doSubscriptions();
    return res.status(200);
  });
  router.use('/getfeedid', async (req, res) => {
    if (enableDebug) {
      console.log("ğŸš§ğŸš§getting feed id", req.query);
    }
    let channel = req.query.channel;
    if (!channel) {
      return res.status(420).send("no channel in feed id request");
    }
    let feed;
    let parts = channel.split('@');
    if (parts.length > 1) {
      let feedApi = "https://" + parts[1] + "/plugins/podcast2/router/getfeedid?channel=" + parts[0];
      try {
        feed = await axios.get(feedApi);
      } catch {
        console.log("ğŸš§ğŸš§hard error getting feed id for ", channel, "from", parts[1], feedApi);
      }
      if (feed && feed.data) {
        //console.log("ğŸš§ğŸš§ returning", feed.data, "for", channel,feed.data.toString());
        return res.status(200).send(feed.data.toString());
      }
      return res.status(420).send("remote channel returned no feed id");
    }
    if (channel) {
      try {
        feed = await storageManager.getData("podcast" + "-" + channel)
      } catch (err) {
        console.log("ğŸš§ğŸš§error getting feedid", channel);
      }
    }
    //console.log("ğŸš§ğŸš§ feed", feed);
    if (feed) {
      return res.status(200).send(feed.toString());
    } else {
      return res.status(400).send("no feed id found for requested channel");
    }
  })
  router.use('/setfeedid', async (req, res) => {
    if (enableDebug) {
      console.log("ğŸš§ğŸš§setting feed id", req.query);
    }
    let channel = req.query.channel;
    let feedID = req.query.feedid;
    if (channel) {
      try {
        await storageManager.storeData("podcast" + "-" + channel, feedID);
        return res.status(200).send();
      } catch (err) {
        console.log("ğŸš§ğŸš§ error storing feedid", channel, feedID);
        return res.status(400).send();
      }
    }
  })
  router.use('/getitemid', async (req, res) => {
    if (enableDebug) {
      console.log("ğŸš§ğŸš§getting item id", req.query);
    }
    let uuid = req.query.uuid;
    let item;
    if (uuid) {
      try {
        item = await storageManager.getData("podcast" + "-" + uuid);
      } catch (err) {
        console.log("ğŸš§ğŸš§ error getting stored itemid", uuid);
      }
    }
    if (item) {
      return res.status(200).send(item.toString());
    } else {
      var apiCall = base + "/api/v1/videos/" + uuid;
      let videoData;
      try {
        videoData = await axios.get(apiCall);
      } catch {
        console.log("ğŸš§ğŸš§failed to pull information for provided video id", apiCall);
      }
      if (videoData) {
        let videoHost = videoData.data.channel.host
        if ("https://" + videoHost != base) {
          let hostApi = "https://" + videoHost + "/plugins/podcast2/router/getitemid?uuid=" + uuid;
          let hostItemId;
          try {
            hostItemId = await axios.get(hostApi);
          } catch {
            console.log("ğŸš§ğŸš§failed to pull item ID from video host", hostApi);
          }
          if (hostItemId) {
            try {
              await storageManager.storeData("podcast" + "-" + uuid, hostItemId);
            } catch {
              console.log("ğŸš§ğŸš§failed to store item ID from host", uuid, hostItemId);
            }
            return res.status(200).send(hostItemId.data.toString());
          } else {
            console.log("ğŸš§ğŸš§ No id provided by hosting instance");
          }
        }
        let channel = videoData.data.channel.name;
        let feedApi = base + "/plugins/podcast2/router/getfeedid?channel=" + channel;
        try {
          feedId = await axios.get(feedApi);
        } catch {
          console.log("ğŸš§ğŸš§ error when tring to get feed id ", feedApi);
          return res.status(404).send();
        }

      }
      console.log("ğŸš§ğŸš§no videodata available", apiCall);
      return res.status(400).send();
    }
  })
  router.use('/setitemid', async (req, res) => {
    if (enableDebug) {
      console.log("ğŸš§ğŸš§setting item id", req.query.uuid);
    }
    let uuid = req.query.uuid;
    let itemID = req.query.itemid;
    if (uuid) {
      try {
        await storageManager.storeData("podcast" + "-" + uuid, itemID);
        return res.sendStatus(200);
      } catch (err) {
        console.log("ğŸš§ğŸš§error setting item id", uuid, itemID);
        return res.sendStatus(400).send();
      }
    }
  })
  router.use('/getchannelguid', async (req, res) => {
    if (enableDebug) {
      console.log("ğŸš§ğŸš§getting channel guid", req.query);
    }
    let host,channelOnly;
    let channel = req.query.channel;
    parts = channel.split("@");
    if (parts.length>1){
      host = parts[1];
      channelOnly = parts[0];
    }
    let channelGuid;
    if (enableDebug) {
      console.log("ğŸš§ğŸš§ channel guid info", channel,host,channelOnly,channelGuid,parts);
    }    
    if (channel) {
      try {
        channelGuid = await storageManager.getData("channelguid" + "-" + channel)
          if (enableDebug) {
            console.log("ğŸš§ğŸš§channel guid from storage", channelGuid);
          }
      } catch (err) {
        console.log("ğŸš§ğŸš§ error getting channel guid", channel);
        return res.status(400).send();
      }
      if (!channelGuid){
        try {
          channelGuid = await storageManager.getData("podcast" + "-" + channel)
          if (enableDebug) {
            console.log("ğŸš§ğŸš§channel guid from lightning storage", channelGuid);
          }
        } catch (err) {
          console.log("ğŸš§âš¡ï¸ğŸš§âš¡ï¸ğŸš§ error getting lighting feedid", channel);
        }
      }
    }
    if (!channelGuid &&  host && host !=hostDomain){
      apiUrl = `https://${host}/plugins/podcast2/router/getchannelguid?channel=${channel}`;
      try {
        console.log("ğŸš§ğŸš§ stuff",base,host,apiUrl);
        let guidData = await axios.get(apiUrl);
        if (guidData && guidData.data) {
          //console.log("ğŸš§ğŸš§channel guid", guidData.data);
          channelGuid = guidData.data;
          if (enableDebug) {
            console.log("ğŸš§ğŸš§channel guid from remote",host, channelGuid);
          }
        }
      } catch {
        console.log("ğŸš§ğŸš§unable to load channel guid", apiUrl);
      }
      if (!channelGuid){
        let feedApi = `https://${host}/plugins/lightning/router/getchannelguid?channel=${channel}`;
        let guidData;
        try {
          guidData = await axios.get(feedApi);
        } catch {
          console.log("ğŸš§âš¡ï¸ğŸš§âš¡ï¸ğŸš§ hard error getting lighting feed id for ", channel, "from", host, feedApi);
        }
        if (guidData && guidData.data) {
          //console.log("âš¡ï¸âš¡ï¸ returning", feed.data, "for", channel,feed.data.toString());
          channelGuid = guidData.data;
          if (enableDebug) {
            console.log("ğŸš§ğŸš§channel guid from remote lighting", channelGuid);
          }
        }
      }
    }
    if (channelGuid) {
      return res.status(200).send(channelGuid);
    } else {
      //TODO properly create guid
      //let guidResolverUrl = "https://guid.peertube.support/"
      if (enableDebug) {
        console.log("ğŸš§ğŸš§ no channel guid found, creating one");
      }  
      let rssUrl;
      if (channelOnly){
        rssUrl= await getRss(channelOnly);
      } else {
        rssUrl = await getRss(channel);
      }
      if (enableDebug) {
        console.log("ğŸš§ğŸš§creating podcast index from", rssUrl);
      }
      channelGuid = await v5('url',rssUrl);
      if (enableDebug) {
        console.log("ğŸš§ğŸš§channel guid generated", channelGuid,rssUrl);
      }
      if (channelGuid) {
        try {
          await storageManager.storeData("channelguid" + "-" + channel, channelGuid);
        } catch {
          console.log("ğŸš§ğŸš§failed to store channel guid", channel, channelGuid);
        }
        let setFeedApi = `https://${host}/plugins/lightning/router/setfeedid?channel=${channel}&feedid=${channelGuid}`;
        try {
          feed = await axios.get(feedApi);
        } catch {
          console.log(`ğŸš§âš¡ï¸ğŸš§âš¡ï¸ğŸš§ hard error setting lightning feed id for ${channel} from ${host}`);
        }      
        return res.status(200).send(channelGuid);
      } else {
        console.log("ğŸš§ğŸš§ error attempting to generate channel guiid",channel);
        return res.status(400).send();
      }
    }
  })
  router.use('/getpoddata', async (req, res) => {
    
    if (enableDebug) {
      console.log("ğŸš§ğŸš§getting pod data", req.query);
    }
    let channel = req.query.channel;
    if (!channel) {
      console.log("ğŸš§ğŸš§ no channel in query", channel, req.query);
      return res.status(400).send("ğŸš§ğŸš§ no channel value in request " + req.query);
    }
    let parts = channel.split('@');
    let remotePodData;
    if (parts.length > 1) {
      let remotePodApi = "https://" + parts[1] + "/plugins/podcast2/router/getpoddata?channel=" + parts[0];
      try {
        remotePodData = await axios.get(remotePodApi);
      } catch (err) {
        console.log("ğŸš§ğŸš§hard error getting custom remote pod data for ", channel, "from", parts[1], remotePodApi, err);
        return res.status(400).send("ğŸš§ğŸš§hard error getting custom remote pod data for " + channel + " from " + parts[1] + " using " + remotePodApi + " error " + err);
      }
      if (remotePodData) {
        //console.log("ğŸš§ğŸš§ returning", customChat.toString(), "for", channel);
        return res.status(200).send(remotePodData.data);
      }
      console.log("ğŸš§ğŸš§ no remote pod data found for", channel);
      return res.status(404).send("ğŸš§ğŸš§ no podcast data for " + channel + " on remote system");
    }
    let podData;
    try {
      podData = await storageManager.getData("pod-" + channel.replace(/\./g, "-"));
    } catch (err) {
      console.log("ğŸš§ğŸš§error getting pod data for ", channel);
      return res.status(404).send("ğŸš§ğŸš§ no podcast data for " + req.query.channel + err);
    }
    if (podData) {
      return res.status(200).send(podData);
    } else {
      console.log("ğŸš§ğŸš§ no pod data found for", channel);
      return res.status(404).send("ğŸš§ğŸš§ no pod data found for " + channel);
    }
  })
  router.use('/setpoddata', async (req, res) => {
    if (enableDebug) {
      console.log("ğŸš§ğŸš§setting podcast data", req.query, req.body);
    }
    //TODO verify authorized user is actual owner of room
    
    if (user && user.dataValues && req.body) {
      let userName = user.dataValues.username;
      if (enableDebug) {
        console.log("ğŸš§ğŸš§ğŸš§ got authorized peertube user to set pod data ", user.dataValues.username);
      }
      if (enableDebug) {
        console.log("ğŸš§ğŸš§ğŸš§ğŸš§ user", userName);
      }
      let channel = req.body.channel;
      storageManager.storeData("pod-" + channel.replace(/\./g, "-"), req.body);
      if (req.body && req.body.feedguid && req.body.feedguid !=``) {
        try {
          channelGuid = await storageManager.storeData("channelguid" + "-" + req.body.feedguid)
        } catch (err) {
          console.log("ğŸš§ğŸš§ error setting channel guid", channel);
        }
      }
      pingPI(channel);
      return res.status(200).send();
    }
    return res.status(420).send();
  })
  router.use('/importchannel', async (req, res) => {
    if (enableDebug) {
      console.log("ğŸš§ğŸš§importing channel data", req.query, req.body);
    }
    let feed;
    try {
      feed = await parser.parseURL(req.query.clone);
    } catch {
      console.log("error loading rss feed",req.query.clone);
      return res.status(420).send("hard error loading feed: "+req.query.clone);
    }
    if (!feed){
      console.log("error loading rss feed",req.query.clone);
      return res.status(420).send("error loading feed : "+req.query.clone);  
    }
    let header = req.body.bear;
    //TODO funding -> support
    let fixedName;
    if (feed.title){
      fixedName = feed.title.replace(/\W/g, '').toLowerCase();
      if (fixedName.length>25){
        fixedName =fixedName.slice(0,25);
      }
    } else {
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§ Unable to find channel name in provided feed", req.query.clone);
      return res.status(420).send("No Channel title found in stream:"+req.query.clone);
    }
    let getChannelApi = base+"/api/v1/video-channels/"+fixedName;
    let channelData;
    let channelId;
    let description
    let imageUrl;
    let displayName = feed.title.replace(/[^\w\s]/gi, '');
    if (feed.description){
      description = feed.description.replace(/[^\w\s]/gi, '')
      if (description.length>990){
        description = feed.description.slice(0,990);
      }
    }
    console.log("ğŸš§ğŸš§ new channel info",fixedName.length,displayName.length,description.length);
    try {
      channelData = await axios.get(getChannelApi);
    } catch (err) {
      console.log(`ğŸš§ğŸš§ no channel ${getChannelApi} found`);
    }
    if (channelData && channelData.data && channelData.data.id){
      channelId = channelData.data.id
      console.log("ğŸš§ğŸš§ got existing channel info ",channelData.data);
    } else {
      let newChannel ={
        "displayName": displayName,
        "name": fixedName,
        "description": description,
      }
      console.log("new channel object",newChannel,header);
      let result = await createChannel(newChannel,header);
      // console.log("ğŸš§ğŸš§ created channel",result.data, result.data.id, result.data.videoChannel.id);
      if (result && result && result.videoChannel && result.videoChannel.id){
        channelId = result.videoChannel.id;
      }
    }

    if (!channelId){
      console.log("ğŸš§ğŸš§ no channelId, unable to proceed");
      return res.status(420).send("No Channel ID found or created for :"+req.query.clone);
    }
    if (fixedName){
      let newChannelPath = base + `/c/${fixedName}`;
      console.log (`ğŸš§ğŸš§ redirecting to  ${newChannelPath}`);
      res.status(200).send(newChannelPath);
    } else {
      console.log (`ğŸš§ğŸš§ unable to redirect to  ${newChannelPath}`);
    }
    if (feed.image){
      imageUrl = feed.image.url;
      if (!imageUrl){
        imageUrl = feed.image.href;
      }
    }
    if (!imageUrl  && (typeof feedimage === 'string' || feed.image instanceof String)){
      imageUrl = feed.image;
    }
    if (!imageUrl && feed.itunes && feed.itunes.image){
      imageUrl = feed.itunes.image.url;
    }
    if (!imageUrl && feed.itunes && feed.itunes.image){
      imageUrl = feed.itunes.image;
    } 
    if (!imageUrl){
      console.log("ğŸš§ğŸš§ no  image url",feed.itunes);
    }
    console.log("ğŸš§ğŸš§final image url",imageUrl);
    let avatarResult = await updateChannelAvatar(imageUrl,fixedName,header);
    console.log("ğŸš§ğŸš§ avatar upload result",avatarResult)
    console.log("ğŸš§ğŸš§ Starting to process rss stream items",channelId,fixedName,feed.title);     
    for (var item of feed.items){
      item.channelId = channelId;
      let importBody = await rssJsonToApiJson(item);
      console.log("ğŸš§ğŸš§ json", item, importBody);
      let dupeResult = await checkForDuplicate(importBody);
      if (dupeResult){
        console.log("ğŸš§ğŸš§ skipping duplicate");
        continue;
      }
      let importApi = base+"/api/v1/videos/imports";
      
      let result;
      try {
        result = await axios.post(importApi,importBody,{ headers: header });
      } catch (err){
        console.log("ğŸš§ğŸš§ hard error importing podcast",importApi,importBody,header,err);
      }
    }
  })
  async function pingPI(pingChannel) {
    let feedApi = base + "/plugins/podcast2/router/getfeedid?channel=" + pingChannel;
    let feedId;
    try {
      feedId = await axios.get(feedApi);
      let pingResult;
      if (feedId) {
        pingResult = await axios.get("https://api.podcastindex.org/api/1.0/hub/pubnotify?id=" + feedId.data);
      }
      if (pingResult && pingResult.data) {
        return (pingResult.data);
      }
    } catch {
      console.log("ğŸš§ğŸš§hard error when trying ping podcast index ", feedId, feedApi);
    }
  }
  async function getRss(channel){
    let apiUrl = base + "/api/v1/video-channels/" + channel;
    let channelData;
    try {
      channelData = await axios.get(apiUrl);
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§ getting rss base for", channelData.data);
    } catch {
      console.log("ğŸš§ğŸš§ğŸš§ğŸš§unable to load channel info", apiUrl);
      return ;
    }
    
    let rssUrl = base + "/feeds/podcast/videos.xml?videoChannelId="+channelData.data.id
    return rssUrl;
  }
  async function getConfigPanel(splitInfo, channel) {
    let feedID = await getFeedID(channel);
    if (debugEnabled) {
      console.log("ğŸš§getting config panel", splitInfo, feedID, channel);
    }
    let html = `<br><label _ngcontent-msy-c247="" for="Wallet">Lightning Splits</label><br>`
    if (splitInfo && (keysendEnabled || lnurlEnabled)) {
      if (splitInfo.length > 0) {
        html = html + "<table><th>Split %</th><th><center>Lighting Address</center></th><th>Address Type</th></tr>";
        for (var split in splitInfo) {
          let displayName = splitInfo[split].name;
          if (!displayName) {
            displayName = splitInfo[split].address;
          }
          html = html + "<tr><td>" + splitInfo[split].split + "</td><td>" + displayName + "</td>";
          if (splitInfo[split].keysend) {
            html = html + `<td>Keysend</td>`;
          } else if (splitInfo[split].customKeysend) {
            html = html + `<td>Node</td>`;
          } else if (splitInfo[split].lnurl) {
            html = html + "<td>LNURL Pay</td>";
          } else {
            html = html + "<td>unknown</td>"
          }
          if (!splitInfo[split].fee) {
            html = html + `<td><div class="peertube-button orange-button ng-star-inserted" slot="` + split + `" id="edit-` + split + `">edit</div></td>`;
            //html = html + `<td><button class="peertube-button orange-button ng-star-inserted" >edit</button></td>`;
          }
          html = html + "</tr>";
        }
        html = html + "</table>";
      }
      html = html + `<button type="button" id="add-split" class="peertube-button orange-button ng-star-inserted">Add Split</button>`
    } else {
      html = html + `<button type="button" id="create-split" class="peertube-button orange-button ng-star-inserted">Add Lightning Address</button>`

    }
    if (rssEnabled) {
      html = html + "<hr>"
      html = html + `<button type="button" id="rss-settings" name="ress-settings" class="peertube-button orange-button ng-star-inserted">Podcasting 2.0 RSS settings</button>`;
    }


    html = html + "<hr>"

    //html = html + "<br>podcast 2.0 RSS feed URL: " + rssFeedUrl;
    const panel = document.createElement('div');
    panel.setAttribute('class', 'lightning-button');
    panel.setAttribute('sandbox', 'allow-same-origin allow-scripts allow-popups allow-forms')
    panel.innerHTML = html;
    return panel;
  }
  async function getImage(imageUrl,channel,header){
    console.log("ğŸš§oh boy, this again",imageUrl,channel,header);
    if (!imageUrl){
      return undefined;
    }
    var fileName = channel + "-avatar.jpg";
    var downloader = new Downloader({
      url: imageUrl,
      directory: basePath + "/avatars",
      fileName: fileName,
      cloneFiles: false
    })
    try {
      var avatarDownloadResult = await downloader.download();
      console.log('ğŸš§downloaded', avatarDownloadResult);
    } catch (error) {
      console.log('ğŸš§Download failed', fileName, error)
    }
    console.log("ğŸš§avatar  downloaded", avatarDownloadResult);
    form = new FormData;
    form.append( 'avatarfile', fs.createReadStream(basePath + '/avatars/'+fileName, {filename: 'bar.jpg', contentType: 'image/jpeg'} ));
    const formHeaders = form.getHeaders();
    console.log("ğŸš§ form headers",formHeaders);
    let mergeheaders = {
      ...header,
      ...formHeaders,
    }
    console.log("ğŸš§ form headers2",formHeaders);
    let avatarUrl = base+`/api/v1/video-channels/${channel}/avatar/pick`;
    await axios.post(avatarUrl, form, {
      headers: {
        ...mergeheaders,
      },
    })
      .then(response => response)
      .catch(error => error)
      return ;
    /*

    let dataString = fs.createReadStream(basePath + "/avatars/" + fileName)
    //return dataString;
    let gorf = new FormData()
    gorf.append('avatarfile', dataString)
    console.log("ğŸš§ğŸš§ fs on downloaded file version",gorf);
    * /
    let data;
    try {
      data = await imageDataURI.encodeFromURL(imageUrl);
    } catch (err) {
      console.log("ğŸš§ğŸš§ Hard error getting image from url",imageUrl);
    }
    let gank = new FormData()
    gank.append('avatarfile',data);
    gank.append('filename',"eatme.jpg");
    console.log("imageDataURI version",gank, "\n\n\n\n\n\n\n",gank._streams[0]);
    return gank._streams[0];
    
    try {
      request.defaults({ encoding: null });
      request.get('imageUrl', function (error, response, body) {
          if (!error && response.statusCode == 200) {
              data = "data:" + response.headers["content-type"] + ";base64," + Buffer.from(body).toString('base64');
              console.log("ğŸš§ğŸš§ image string",data,new FormData().append('avatarfile', data));
          }
      });
    } catch {
      console.log("ğŸš§ğŸš§ stuff done blown up");  
    }
    let image = await axios.get(imageUrl, {responseType: 'arraybuffer'});
    let returnedB64 = Buffer.from(image.data).toString('base64');
    let geek = new FormData()
    geek.append('avatarfile', returnedB64);
    console.log("ğŸš§ğŸš§ axios get version ", geek,);
  */
  var form = new FormData();

//form.append('my_field', 'my value');
//form.append('my_buffer', new Buffer(10));
form.append('avatarfile', request(imageUrl));
form.submit('http://example.org/', function(err, res) {
  // res â€“ response object (http.IncomingMessage)  //
  res.resume();
  console.log("res");
});
  }
  async function rssJsonToApiJson(rss){
    if (!rss){
      console.log("ğŸš§ğŸš§ no rss");
      return
    }
    let api = {}
    if (!rss.channelId || !rss.title || !rss.enclosure){
      return false;
    }

    if (rss.content){
      if (rss.content.length>990){rss.content=rss.content.slice(0,990)}
      api.description=rss.content;
    }
    api.nsfw = false;
    api.language = "en";
    api.privacy = 1;
    api.channelId = rss.channelId;
    api.name = rss.title;
    if (api.name.length>119){
      api.name = api.name.slice(0,119);
    }
    if (rss.enclosure){
      api.targetUrl = rss.enclosure.url;
    }
    if (rss.category){
      console.log("TODO category conversion is hard, check rss2peertube for help");
    }
    if ( rss && rss.itunes && rss.itunes.explicit && rss.itunes.explicit.toLowerCase() == "yes"){
      api.nsfw=true;
    }
    if (rss.isoDate){
      api.originallyPublishedAt = rss.isoDate;
    }
    if (rss.value){
      api.support = rss.value;
    }
    let imageUrl;
    console.log("itunes",rss.itunes,"image",rss.image);
    if (rss.itunes){
      if (rss.itunes.image && rss.itunes.image.url){
        imageUrl=rss.itunes.image.url;
      } else if (rss.itunes.image && rss.itunes.image.href){
        imageUrl =rss.itunes.image.href;
      } else if (rss.itunes.image){
        imageUrl = rss.itunes.image;
      }
    }
    if (rss.image){
      if (rss.image.url){
        imageUrl=rss.image.url;
      } else {
        if (rss.image.href){
          imageUrl =rss.image.href;
        }else {
          imageUrl = rss.image;
        }
      }
    } 
    console.log("ğŸš§ğŸš§ found image",imageUrl); 
    if (imageUrl){
      api.thumbnailfile=await getThumbnail(imageUrl);
    }
    console.log(" what we're laying down",api,"thumbnail",api.thumbnailfile, "buffer",api.buffer);
    return api;
  }
  async function createChannel(channel,header ){
    console.log("ğŸš§ğŸš§ creating channel",channel,header);
    let url = base+"/api/v1/video-channels";
    try {
      let result = await axios.post(url,channel,{ headers: header });
      if (result){
        return result.data;
      } else {
        return undefined
      }
    } catch (err){
      console.log("ğŸš§ğŸš§ error creating channel",channel,header,err);
      return undefined;
    }
  }
  async function updateChannelAvatar(imageUrl, channel,header ){
    console.log(`ğŸš§ updateing ${channel} avatar to ${imageUrl}`);
    if (!imageUrl || !channel || !header ){
      console.log('ğŸš§bad or missing arguments',imageUrl,channel,header);
      return undefined;
    }
    var fileName = channel + "-avatar.jpg";
    var downloader = new Downloader({
      url: imageUrl,
      directory: basePath + "/avatars",
      fileName: fileName,
      cloneFiles: false
    })
    try {
      var avatarDownloadResult = await downloader.download();
      console.log('ğŸš§downloaded', avatarDownloadResult);
    } catch (error) {
      console.log('ğŸš§Download failed', fileName, error)
    }
    console.log("ğŸš§avatar  downloaded", avatarDownloadResult);
    form = new FormData;
    await form.append( 'avatarfile', fs.createReadStream(basePath + '/avatars/'+fileName, {filename: 'bar.jpg', contentType: 'image/jpeg'} ));
    const formHeaders = form.getHeaders();
    console.log("ğŸš§ form headers",formHeaders);
    let mergeheaders = {
      ...header,
      ...formHeaders,
    }
    console.log("ğŸš§ form headers2",formHeaders);
    let avatarUrl = base+`/api/v1/video-channels/${channel}/avatar/pick`;
    let avatarResult;
    try {
      avatarResult = await axios.post(avatarUrl, form, {
        headers: {
          ...mergeheaders,
        },
      })
    } catch (err) {
      console.log("ğŸš§ error setting avatar",err )
    }
      return avatarResult;
  }
  async function getThumbnail(imageUrl){
    console.log(`ğŸš§ getting thumbnail from ${imageUrl}`);
    if (!imageUrl){
      console.log('ğŸš§bad or missing arguments',imageUrl);
      return undefined;
    }
    var fileName = "thumbnail.jpg";
    var downloader = new Downloader({
      url: imageUrl,
      directory: basePath + "/thumbnails",
      fileName: fileName,
      cloneFiles: false
    })
    try {
      var thumbnailloadResult = await downloader.download();
      console.log('ğŸš§downloaded', thumbnailloadResult);
    } catch (error) {
      console.log('ğŸš§Download failed', fileName, error)
    }
    console.log("ğŸš§thumbnail downloaded", thumbnailloadResult);
    form = new FormData;
    await form.append( 'thumbnailfile', fs.createReadStream(basePath + '/thumbnailss/'+fileName, {filename: 'thumbnail.jpg', contentType: 'image/jpeg'} ));
    console.log("ğŸš§ form ",form);
    return form;
  }  
  async function getPeerTubeToken(username, password) {
    var clientTokenPath = base + "/api/v1/oauth-clients/local";
    var userTokenPath = base + "/api/v1/users/token";
    try {
      let clientResult = await axios.get(clientTokenPath);
      if (clientResult && clientResult.data) {
        let peertubeClientId = clientResult.data.client_id;
        let clientSecret = clientResult.data.client_secret;
        var data = new URLSearchParams();
        data.append('client_id', peertubeClientId);
        data.append('client_secret', clientSecret);
        data.append('grant_type', 'password');
        data.append('response_type', 'code');
        data.append('username', username);
        data.append('password', password);
        var postData = data.toString();
        let tokenresponse = await axios.post(userTokenPath, data);
        console.log("token request respoonse", tokenresponse.data);
        bearerToken = tokenresponse.data.access_token;
        return (bearerToken);
      } else {
        console.log("failed to get client token");
      }
    } catch (error) {
      console.log("error in get token", ptuser, ptpassword, ptApi);
      return (-1);
    }
    return;
  }
  async function checkForDuplicate(itemJson){
    console.log("ğŸš§ looking fo dips",itemJson);
    let eSearch = encodeURIComponent(itemJson.name);
    let searchApi = base+`/api/v1/search/videos?search=${eSearch}`;
    try {
      searchResult = await axios.get(searchApi);

    } catch (err) {
      console.log("ğŸš§ hard error trying to search for video dupes ",searchApi,err);
    }
    if (searchResult && searchResult.data && searchResult.data && Array.isArray(searchResult.data)){
      for (var match of searchResult.data){
        console.log("ğŸš§ found these dupes",match.channel);
      }
    } else {
      console.log("ğŸš§ no result from search, should be unique");
      return (false)
    }
  }
}
async function unregister () {
  return
}

module.exports = {
  register,
  unregister
}
