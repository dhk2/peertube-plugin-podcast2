const axios = require('axios');
const { version } = require('./package.json');
const fs = require('fs');
const { Console } = require('console');
var v5 = require('uuidv5');

async function register ({
  registerHook,
  registerSetting,
  settingsManager,
  storageManager,
  peertubeHelpers,
  getRouter,
  videoCategoryManager,
  videoLicenceManager,
  videoLanguageManager
}) {
    registerSetting({
    name: 'rss-enable',
    default: true,
    label: 'Enable enhanced Podcasting 2.0 configuration',
    type: 'input-checkbox',
    descriptionHTML: 'This will enable enhances podcasting 2.0 namespace configuration via channel managemnt page',
    private: false
  })
  registerSetting({
    name: 'irc-enable',
    default: false,
    label: 'Enable IRC chat for channels',
    type: 'input-checkbox',
    descriptionHTML: 'This will enable IRC chat for every channel. Channels can customize the autogenerated room if they have a preferred room',
    private: false
  })
    registerSetting({
    name: 'debug-enable',
    default: false,
    label: 'Enable diagnostic log updates',
    type: 'input-checkbox',
    descriptionHTML: 'This will create more extensive logging of program state data both client and server side for finding and resolving errors ',
    private: false
  })
  let enableRss = await settingsManager.getSetting("rss-enable");
  let enableChat = await settingsManager.getSettings("irc-enable");
  let enableDebug = await settingsManager.getSetting("debug-enable");
  var base = await peertubeHelpers.config.getWebserverUrl();
  var serverConfig = await peertubeHelpers.config.getServerConfig();
  var hostName = serverConfig.instance.name;
  console.log("⚡️⚡️ home url",base,hostName);
  console.log("⚡️⚡️⚡️⚡️ Podcast2 plugin started");
  if (enableDebug) {
    console.log("⚡️⚡️ server settings loaded", hostName, base, serverConfig, enableRss,enableChat);
  }
  registerHook({
    target: 'action:api.video.updated',
    handler: ({ video, body }) => {
      if (enableDebug) {
        console.log("⚡️⚡️updating video\n",body.pluginData);
      }
      //if (!body.pluginData) return

      const seasonNode = body.pluginData['seasonnode'];
      const seasonName = body.pluginData['seasonname'];
      const episodeNode = body.pluginData['episodenode'];
      const episodeName = body.pluginData['episodename'];
      const chapters = body.pluginData['chapters'];
      const itemTxt = body.pluginData['itemtxt'];

      //if (!value) return
      storageManager.storeData('seasonnode-' + video.id, seasonNode)
      storageManager.storeData('seasonname-' + video.id, seasonName)
      storageManager.storeData('episodenode-' + video.id, episodeNode)
      storageManager.storeData('episodename-' + video.id, episodeName)
      storageManager.storeData('chapters-' + video.id, chapters)
      storageManager.storeData('itemtxt-' + video.id, itemTxt)
      return;
    }
  })
    registerHook({
    target: 'filter:api.video.get.result',
    handler: async (video) => {
      if (!video) return video
      if (!video.pluginData) video.pluginData = {}

      video.pluginData['itemtxt'] = await storageManager.getData('itemtxt' + '-' + video.id)
      video.pluginData['chapters'] = await storageManager.getData('chapters' + '-' + video.id)
      video.pluginData['seasonnode'] = await storageManager.getData('seasonnode' + '-' + video.id)
      video.pluginData['seasonname'] = await storageManager.getData('seasonname' + '-' + video.id)
      video.pluginData['episodenode'] = await storageManager.getData('episodenode' + '-' + video.id)
      video.pluginData['episodename'] = await storageManager.getData('episodename' + '-' + video.id)

      return video
    }
  })
    registerHook({
    target: 'filter:feed.podcast.channel.create-custom-tags.result',
    handler: async (result, params) => {
      const { videoChannel } = params
      console.log("⚡️⚡️⚡️⚡️ initial channel values ⚡️⚡️⚡️⚡️",params);
      var channel = params.videoChannel.dataValues.Actor.dataValues.preferredUsername;
      let podreturn = [];
      let channelGuid;
      apiUrl = base + "/plugins/podcast2/router/getchannelguid?channel=" + channel;
      try {
        let guidData = await axios.get(apiUrl);
        if (guidData && guidData.data) {
          console.log("⚡️⚡️channel guid", guidData.data,apiUrl);
          channelGuid = guidData.data;
        }
      } catch {
        console.log("⚡️⚡️unable to load channel guid", apiUrl);
      }
      if (channelGuid){
        podreturn.push({
          name: "podcast:guid",
          value: channelGuid,
        });
      }
      console.log("⚡️⚡️unable to load channel guid", apiUrl);
      let podData;
      try {
        podData = await storageManager.getData("pod-" + channel.replace(/\./g, "-"));
        if (enableDebug){
          console.log("⚡️⚡️ got poddata ", channel,podData);
        }
      } catch (err) {
        console.log("⚡️⚡️error getting pod data for ", channel);
      }
      if (podData && Array.isArray(podData.text)){
        podreturn.push({
          name: "podcast:txt",
          value: podData.text[0],
        });
      }
      return result.concat(podreturn)
    }
  })
  registerHook({
    target: 'filter:feed.podcast.video.create-custom-tags.result',
    handler: async (result, params) => {      const { video, liveItem } = params
      //console.log("⚡️⚡️⚡️⚡️ initial video values ⚡️⚡️⚡️⚡️",result,params,params.video);
      if (liveItem) {
      }
      var videoUuid = params.video.dataValues.uuid;
      var storedSplitData = await getSavedSplit(videoUuid);
      var blocks = []
      //var videoJSON = await peertubeHelpers.videos.loadByIdOrUUID(videoUuid);
      //console.log("⚡️⚡️⚡️⚡️ video helper json",videoJSON)
      let customObjects = [];
      let captionApi = base + "/api/v1/videos/" + videoUuid + "/captions";
      let captionResult;
      try {
        captionResult = await axios.get(captionApi);
      } catch (err) {
        console.log("⚡️⚡️failed requesting transcript data", err);
      }
      let captionPath, captionLanguage, captionItem;
      //if (captionResult && captionResult.data && captionResult.data.total > 0) {
      //console.log("⚡️⚡️\ncaption result", captionResult.data);
      for (var captionEntry in captionResult.data.data) {
        captionPath = base + captionEntry.captionPath
        if (captionEntry.language) {
          captionLanguage = captionEntry.language.id;
        }
        if (captionPath.indexOf("vtt") > 1) {
          type = "text/vtt"
        } else {
          type = "text/plain"
          //fixed = fixed + "\n" + spacer + `<podcast:transcript url="` + captionPath + `" language="` + captionLanguage + `" type="text/plain" rel="captions"/>`;
        }
        captionItem = {
          name: "podcast:transcript",
          attributes: {
            "url": captionPath,
            "language": captionLanguage,
            "type": type,
            "rel": "captions"
          }
        };
        customObjects.push(captionItem);
      }
      var apiCall = base + "/api/v1/videos/" + videoUuid;
      let videoData;
      try {
        videoData = await axios.get(apiCall);
      } catch {
        console.log("⚡️⚡️\n\n\n\n\n\nfailed to pull information for provided video id", apiCall);
      }
      if (videoData && videoData.data) {
        let duration = videoData.data.duration;
        let customData = videoData.data.pluginData;
        let filename;
        let smallest = 999999999
        if (videoData.data.streamingPlaylists[0]){
          let videoFiles = videoData.data.streamingPlaylists[0].files;
          if (videoFiles) {
            for (var fileOption of videoFiles) {
              //console.log(fileOption);
              if (fileOption.size < smallest) {
                smallest = fileOption.size;
                filename = fileOption.fileUrl
              }
            }
          }
        }
        var enclosure;
        //console.log("\n⚡️⚡️\n\n\nsmallest??",filename,smallest);
        if (filename) {
          enclosure = {
            name: "audioenclosure",
            attributes: {
              "url": filename,
              type: "video/mp4",
              length: duration
            }
          }
        } 
        if (enclosure) {
          customObjects.push(enclosure);
        }
        console.log("⚡️⚡️\nplugin data", customData);
        
        if (customData && customData.seasonnode){
          let seasonItem = {
            name: "podcast:season",
            value: await customData.seasonnode.toString()
          };
          if (customData.seasonname){
            seasonItem.attributes={
              "name": customData.seasonname
            }
          }
          customObjects.push(seasonItem);
        }
        
        if (customData && customData.episodenode){
          episodeItem = {
            name: "podcast:episode",
            value: await customData.episodenode.toString()
          };
          if (customData.episodename){
            episodeItem.attributes={
              "display": customData.episodename
            }
          }
          customObjects.push(episodeItem);
        }
        
        if (customData && customData.chapters){
          chaptersItem = {
            name: "podcast:chapters",
            attributes: {
              "url": customData.chapters,
              type: "application/json+chapters"
            }
          };
          customObjects.push(chaptersItem);
        }
       
        if (customData && customData.itemtxt){
         // let txtValue=[].push(customData.itemtxt);
          let txtItem = {
            name: "podcast:txt",
            value: customData.itemtxt
          }
          customObjects.push(txtItem);
        }
        
      }
      console.log("custom objects to add to video",customObjects);
      return result.concat(customObjects);
    }
  })
  const router = getRouter();

  router.use('/podcast2', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️ podcast2 request ⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️", req.query);
    }
    if (!enableRss) {
      console.log("⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️⚡️RSS disabled");
      return res.status(403).send();
    }
    if (req.query.channel == undefined) {
      console.log("⚡️⚡️no channel requested", req.query);
      return res.status(404).send();
    }
    let channel = req.query.channel
    let apiUrl = base + "/api/v1/video-channels/" + channel;
    let channelData;
    try {
      channelData = await axios.get(apiUrl);
    } catch {
      console.log("⚡️⚡️⚡️⚡️unable to load channel info", apiUrl);
      return res.status(400).send();
    }
    let smallChannelAvatar, largeChannelAvatar, smallPersonAvatar, largePersonAvatar
    if (channelData && channelData.data && channelData.data.avatars && channelData.data.avatars[1]) {
      smallChannelAvatar = channelData.data.avatars[0].path;
      largeChannelAvatar = channelData.data.avatars[1].path;
    }
    if (channelData && channelData.data && channelData.data.ownerAccount && channelData.data.ownerAccount.avatars && channelData.data.ownerAccount.avatars[1]) {
      smallPersonAvatar = channelData.data.ownerAccount.avatars[0].path;
      largePersonAvatar = channelData.data.ownerAccount.avatars[1].path;
    }
    //console.log("⚡️⚡️⚡️⚡️channel info", channelData.data);
    
    let rssUrl = base + "/feeds/podcast/videos.xml?videoChannelId=" + channelData.data.id;
    let rssData;
    try {
      rssData = await axios.get(rssUrl)
    } catch {
      console.log("⚡️⚡️unable to load rss feed for", channel, rssUrl);
      return res.status(400).send();
    }
    //console.log("⚡️⚡️loaded rss feed from", rssUrl);
    let channelGuid;
    apiUrl = base + "/plugins/podcast2/router/getchannelguid?channel=" + channel;
    try {
      let guidData = await axios.get(apiUrl);
      if (guidData && guidData.data) {
        //console.log("⚡️⚡️channel guid", guidData.data);
        channelGuid = guidData.data;
      }
    } catch {
      console.log("⚡️⚡️unable to load channel guid", apiUrl);
    }
    //TODO figure out how to get info for livechat plugin as well
    let podData
    try {
      podData = await axios.get(base + "/plugins/podcast2/router/getpoddata?channel=" + channel);
    } catch {
      console.log("unable to load PODCAST data");
    }
    if (podData) {
      console.log("⚡️⚡️\n\n\n\n pod dta \n", podData.data);
    }
    let counter = 0;
    let fixed = "";
    let spacer = "";
    let rss = rssData.data;
    let lines = rss.split('\n');
      console.log("⚡️⚡️\n\n\n\n starting linbe loop \n", lines.length,lines[33]);
    //for (const line of lines) {
    let totalSize = lines.length;
    while (counter<totalSize){
      let line = lines[counter];
      //console.log(`⚡️line${counter}:`,line)
      counter++;
      spacer = line.split("<")[0];
      if (line.includes("Toraifōsu") && podData && podData.data) {

        if (podData.data.text) {
          line = line + `\n${spacer}<podcast:txt>${podData.data.text[0]}</podcast:txt>`;
        }
        if (podData.data.feedguid) {
          line = line + `\n${spacer}<podcast:guid>${podData.data.feedguid}</podcast:guid>`;
        }
      }
      if (line.includes("<atom:link")) {
        line = `${spacer}<atom:link href="https://${req.get('host')}${req.originalUrl}" rel="self" type="application/rss+xml" />`;
      }
      var customData = {};
      if (line.includes('<guid')) {
        let shortUuid = line.split(">")[1].split("<")[0].split("/")[4]
        try {
          var videoData = await axios.get(base + "/api/v1/videos/" + shortUuid);
          if (videoData && videoData.data) {
            customData = videoData.data.pluginData;
          }
        } catch (err) {
          console.log("⚡️⚡️⚡️⚡️hard error trying to get video data for RSS feed", err);
        }
        if (enableDebug) {
          console.log("⚡️⚡️⚡️⚡️item plugin data", shortUuid, customData);
        }
        /* moved to shared code 
        if (customData.seasonnode) {
          if (customData.seasonname) {
            line = line + `\n${spacer}<podcast:season name ="${customData.seasonname}">${customData.seasonnode}</podcast:season>`;
          } else {
            line = line + `\n${spacer}<podcast:season>${customData.seasonnode}</podcast:season>`;
          }
        }
        if (customData.episodenode) {
          if (customData.episodename) {
            line = line + `\n${spacer}<podcast:episode display ="${customData.episodename}">${customData.episodenode}</podcast:episode>`;
          } else {
            line = line + `\n${spacer}<podcast:episode>${customData.episodenode}</podcast:episode>`;
          }
        }
        if (customData.chapters) {
          line = line + `\n${spacer}<podcast:chapters url="${customData.chapters}" type="application/json+chapters" />`
        }
        if (customData.itemtxt) {
          line = line + `\n${spacer}<podcast:txt>${customData.itemtxt}</podcast:txt>`;
        }
        */
      }
      if (line.includes("<enclosure") > 0) {
        continue;
      }
      if (line.includes("audioenclosure") > 0) {
        line = line.replace("audioenclosure", "enclosure");
      }
      if (line.includes(`title="HLS"`) && !line.includes(`length="`)) {
        console.log("fixing length");
        line = line.replace(`title="HLS"`, `title="HLS" length ="69"`);
      }
      if (line.includes(`title="HLS"`) && !line.includes(`type="`)) {
        console.log("fixing type");
        line = line.replace(`title="HLS"`, `title="HLS" type="application/x-mpegURL"`);
      }
      if (line.includes(`title="Audio"`) && !line.includes(`type="`)) {
        console.log("fixing type");
        line = line.replace(`title="Audio"`, `title="Audio" type="video/mp4"`);
      }
      if (largeChannelAvatar) {
        line = line.replace(smallChannelAvatar, largeChannelAvatar);
      }
      if (largePersonAvatar) {
        line = line.replace(smallPersonAvatar, largePersonAvatar);
      }
      if (podData && podData.data && podData.data.medium) {
        line = line.replace(`<podcast:medium>video</podcast:medium>`, `<podcast:medium>${podData.data.medium}</podcast:medium>`);
      }
      if (counter > 1) {
        fixed = fixed + '\n' + line;
      } else {
        fixed = line;
      }
    }
    res.setHeader('content-type', 'application/rss+xml');
    console.log("⚡️⚡️\n\n\n\n ending line loop \n",fixed.length);
    return  res.status(200).send(fixed);
    
  })
  router.use('/dirtyhack', async (req, res) => {
    console.log("⚡️⚡️⚡️⚡️ dirty hack",dirtyHack,req.query);
    if (req.query.cp){
      console.log("⚡️⚡️⚡️⚡️ clearing patronage paid days");
      let subscriptions = await storageManager.getData('subscriptions');
      let list = [];
      if (subscriptions){
        for (var sub of subscriptions){
          sub.paiddays=0;
        }
        storageManager.storeData("subscriptions", subscriptions);
        return res.status(200).send(subscriptions);
      }
    }
    doSubscriptions();
    return res.status(200).send(dirtyHack);
  });
  router.use('/getfeedid', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️getting feed id", req.query);
    }
    let channel = req.query.channel;
    if (!channel) {
      return res.status(420).send("no channel in feed id request");
    }
    let feed;
    let parts = channel.split('@');
    if (parts.length > 1) {
      let feedApi = "https://" + parts[1] + "/plugins/podcast2/router/getfeedid?channel=" + parts[0];
      try {
        feed = await axios.get(feedApi);
      } catch {
        console.log("⚡️⚡️hard error getting feed id for ", channel, "from", parts[1], feedApi);
      }
      if (feed && feed.data) {
        //console.log("⚡️⚡️ returning", feed.data, "for", channel,feed.data.toString());
        return res.status(200).send(feed.data.toString());
      }
      return res.status(420).send("remote channel returned no feed id");
    }
    if (channel) {
      try {
        feed = await storageManager.getData("podcast" + "-" + channel)
      } catch (err) {
        console.log("⚡️⚡️error getting feedid", channel);
      }
    }
    //console.log("⚡️⚡️ feed", feed);
    if (feed) {
      return res.status(200).send(feed.toString());
    } else {
      return res.status(400).send("no feed id found for requested channel");
    }
  })
  router.use('/setfeedid', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️setting feed id", req.query);
    }
    let channel = req.query.channel;
    let feedID = req.query.feedid;
    if (channel) {
      try {
        await storageManager.storeData("podcast" + "-" + channel, feedID);
        return res.status(200).send();
      } catch (err) {
        console.log("⚡️⚡️ error storing feedid", channel, feedID);
        return res.status(400).send();
      }
    }
  })
  router.use('/getitemid', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️getting item id", req.query);
    }
    let uuid = req.query.uuid;
    let item;
    if (uuid) {
      try {
        item = await storageManager.getData("podcast" + "-" + uuid);
      } catch (err) {
        console.log("⚡️⚡️ error getting stored itemid", uuid);
      }
    }
    if (item) {
      return res.status(200).send(item.toString());
    } else {
      var apiCall = base + "/api/v1/videos/" + uuid;
      let videoData;
      try {
        videoData = await axios.get(apiCall);
      } catch {
        console.log("⚡️⚡️failed to pull information for provided video id", apiCall);
      }
      if (videoData) {
        let videoHost = videoData.data.channel.host
        if ("https://" + videoHost != base) {
          let hostApi = "https://" + videoHost + "/plugins/podcast2/router/getitemid?uuid=" + uuid;
          let hostItemId;
          try {
            hostItemId = await axios.get(hostApi);
          } catch {
            console.log("⚡️⚡️failed to pull item ID from video host", hostApi);
          }
          if (hostItemId) {
            try {
              await storageManager.storeData("podcast" + "-" + uuid, hostItemId);
            } catch {
              console.log("⚡️⚡️failed to store item ID from host", uuid, hostItemId);
            }
            return res.status(200).send(hostItemId.data.toString());
          } else {
            console.log("⚡️⚡️ No id provided by hosting instance");
          }
        }
        let channel = videoData.data.channel.name;
        let feedApi = base + "/plugins/podcast2/router/getfeedid?channel=" + channel;
        try {
          feedId = await axios.get(feedApi);
        } catch {
          console.log("⚡️⚡️ error when tring to get feed id ", feedApi);
          return res.status(404).send();
        }

      }
      console.log("⚡️⚡️no videodata available", apiCall);
      return res.status(400).send();
    }
  })
  router.use('/setitemid', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️setting item id", req.query.uuid);
    }
    let uuid = req.query.uuid;
    let itemID = req.query.itemid;
    if (uuid) {
      try {
        await storageManager.storeData("podcast" + "-" + uuid, itemID);
        return res.sendStatus(200);
      } catch (err) {
        console.log("⚡️⚡️error setting item id", uuid, itemID);
        return res.sendStatus(400).send();
      }
    }
  })
  router.use('/getchannelguid', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️getting channel guid", req.query);
    }
    let host,channelOnly;
    let channel = req.query.channel;
    parts = channel.split("@");
    if (parts.length>1){
      host = parts[1];
      channelOnly = parts[0];
    }
    let channelGuid;
    if (channel) {
      try {
        channelGuid = await storageManager.getData("channelguid" + "-" + channel)
      } catch (err) {
        console.log("⚡️⚡️ error getting channel guid", channel);
        return res.status(400).send();
      }
    }
    if (!channelGuid && host){
      apiUrl = `https://${host}/plugins/podcast2/router/getchannelguid?channel=${channelOnly}`;
      try {
        console.log("⚡️⚡️ stuff",base,host,apiUrl);
        let guidData = await axios.get(apiUrl);
        if (guidData && guidData.data) {
          //console.log("⚡️⚡️channel guid", guidData.data);
          channelGuid = guidData.data;
        }
      } catch {
        console.log("⚡️⚡️unable to load channel guid", apiUrl);
      }
    }
    if (channelGuid) {
      return res.status(200).send(channelGuid);
    } else {
      //TODO properly create guid
      //let guidResolverUrl = "https://guid.peertube.support/"  
      let rssUrl;
      if (channelOnly){
        rssUrl= await getRss(channelOnly);
      } else {
        rssUrl = await getRss(channel);
      }
      channelGuid = await v5('url',rssUrl);
      if (channelGuid) {
        try {
          await storageManager.storeData("channelguid" + "-" + channel, channelGuid);
        } catch {
          console.log("⚡️⚡️failed to store channel guid", channel, channelGuid);
        }
        return res.status(200).send(channelGuid);
      } else {
        console.log("⚡️⚡️ error attempting to generate channel guiid",channel);
        return res.status(400).send();
      }
    }
  })
  router.use('/getpoddata', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️getting pod data", req.query);
    }
    let channel = req.query.channel;
    if (!channel) {
      console.log("⚡️⚡️ no channel in query", channel, req.query);
      return res.status(400).send("⚡️⚡️ no channel value in request " + req.query);
    }
    let parts = channel.split('@');
    let remotePodData;
    if (parts.length > 1) {
      let remotePodApi = "https://" + parts[1] + "/plugins/podcast2/router/getpoddata?channel=" + parts[0];
      try {
        remotePodData = await axios.get(remotePodApi);
      } catch (err) {
        console.log("⚡️⚡️hard error getting custom remote pod data for ", channel, "from", parts[1], remotePodApi, err);
        return res.status(400).send("⚡️⚡️hard error getting custom remote pod data for " + channel + " from " + parts[1] + " using " + remotePodApi + " error " + err);
      }
      if (remotePodData) {
        //console.log("⚡️⚡️ returning", customChat.toString(), "for", channel);
        return res.status(200).send(remotePodData.data);
      }
      console.log("⚡️⚡️ no remote pod data found for", channel);
      return res.status(404).send("⚡️⚡️ no podcast data for " + channel + " on remote system");
    }
    let podData;
    try {
      podData = await storageManager.getData("pod-" + channel.replace(/\./g, "-"));
    } catch (err) {
      console.log("⚡️⚡️error getting pod data for ", channel);
      return res.status(404).send("⚡️⚡️ no podcast data for " + req.query.channel + err);
    }
    if (podData) {
      return res.status(200).send(podData);
    } else {
      console.log("⚡️⚡️ no pod data found for", channel);
      return res.status(404).send("⚡️⚡️ no pod data found for " + channel);
    }
  })
  router.use('/setpoddata', async (req, res) => {
    if (enableDebug) {
      console.log("⚡️⚡️setting podcast data", req.query, req.body);
    }
    //TODO verify authorized user is actual owner of room
    let user = await peertubeHelpers.user.getAuthUser(res);
    if (user && user.dataValues && req.body) {
      let userName = user.dataValues.username;
      if (enableDebug) {
        console.log("⚡️⚡️⚡️ got authorized peertube user to set pod data ", user.dataValues.username);
      }
      if (enableDebug) {
        console.log("⚡️⚡️⚡️⚡️ user", userName);
      }
      let channel = req.body.channel;
      storageManager.storeData("pod-" + channel.replace(/\./g, "-"), req.body);
      pingPI(channel);
      return res.status(200).send();
    }
    return res.status(420).send();
  })
  async function pingPI(pingChannel) {
    let feedApi = base + "/plugins/podcast2/router/getfeedid?channel=" + pingChannel;
    let feedId;
    try {
      feedId = await axios.get(feedApi);
      let pingResult;
      if (feedId) {
        pingResult = await axios.get("https://api.podcastindex.org/api/1.0/hub/pubnotify?id=" + feedId.data);
      }
      if (pingResult && pingResult.data) {
        return (pingResult.data);
      }
    } catch {
      console.log("⚡️⚡️hard error when trying ping podcast index ", feedId, feedApi);
    }
  }
  
}

async function unregister () {
  return
}

module.exports = {
  register,
  unregister
}
