const axios = require('axios');
const { version } = require('./package.json');
const fs = require('fs');
const { Console } = require('console');
var v5 = require('uuidv5');
let Parser = require('rss-parser');
const FormData = require('form-data');
const imageDataURI = require('image-data-uri');
const { stringify } = require('querystring');
var request = require('request')
const Downloader = require('nodejs-file-downloader');

async function register ({
  registerHook,
  registerSetting,
  settingsManager,
  storageManager,
  peertubeHelpers,
  getRouter,
  videoCategoryManager,
  videoLicenceManager,
  videoLanguageManager
}) {
    registerSetting({
    name: 'rss-enable',
    default: true,
    label: 'Enable enhanced Podcasting 2.0 configuration',
    type: 'input-checkbox',
    descriptionHTML: 'This will enable enhances podcasting 2.0 namespace configuration via channel managemnt page',
    private: false
  })
  registerSetting({
    name: 'irc-enable',
    default: false,
    label: 'Enable IRC chat for channels',
    type: 'input-checkbox',
    descriptionHTML: 'This will enable IRC chat for every channel. Channels can customize the autogenerated room if they have a preferred room',
    private: false
  })
    registerSetting({
    name: 'debug-enable',
    default: false,
    label: 'Enable diagnostic log updates',
    type: 'input-checkbox',
    descriptionHTML: 'This will create more extensive logging of program state data both client and server side for finding and resolving errors ',
    private: false
  })
  let enableRss = await settingsManager.getSetting("rss-enable");
  let enableChat = await settingsManager.getSettings("irc-enable");
  let enableDebug = await settingsManager.getSetting("debug-enable");
  var base = await peertubeHelpers.config.getWebserverUrl();
  var basePath = peertubeHelpers.plugin.getDataDirectoryPath();
  var serverConfig = await peertubeHelpers.config.getServerConfig();
  var hostName = serverConfig.instance.name;
  console.log("ðŸš§ðŸš§ home url",base,hostName);
  console.log("ðŸš§ðŸš§ðŸš§ðŸš§ Podcast2 plugin started");
  if (enableDebug) {
    console.log("ðŸš§ðŸš§ server settings loaded", hostName, base, serverConfig, enableRss,enableChat);
  }
  let Parser = require('rss-parser');
  let parser = new Parser();
  registerHook({
    target: 'action:api.video.updated',
    handler: ({ video, body }) => {
      if (enableDebug) {
        console.log("ðŸš§ðŸš§updating video\n",body.pluginData);
      }
      //if (!body.pluginData) return

      const seasonNode = body.pluginData['seasonnode'];
      const seasonName = body.pluginData['seasonname'];
      const episodeNode = body.pluginData['episodenode'];
      const episodeName = body.pluginData['episodename'];
      const chapters = body.pluginData['chapters'];
      const itemTxt = body.pluginData['itemtxt'];

      //if (!value) return
      storageManager.storeData('seasonnode-' + video.id, seasonNode)
      storageManager.storeData('seasonname-' + video.id, seasonName)
      storageManager.storeData('episodenode-' + video.id, episodeNode)
      storageManager.storeData('episodename-' + video.id, episodeName)
      storageManager.storeData('chapters-' + video.id, chapters)
      storageManager.storeData('itemtxt-' + video.id, itemTxt)
      return;
    }
  })
    registerHook({
    target: 'filter:api.video.get.result',
    handler: async (video) => {
      if (!video) return video
      if (!video.pluginData) video.pluginData = {}

      video.pluginData['itemtxt'] = await storageManager.getData('itemtxt' + '-' + video.id)
      video.pluginData['chapters'] = await storageManager.getData('chapters' + '-' + video.id)
      video.pluginData['seasonnode'] = await storageManager.getData('seasonnode' + '-' + video.id)
      video.pluginData['seasonname'] = await storageManager.getData('seasonname' + '-' + video.id)
      video.pluginData['episodenode'] = await storageManager.getData('episodenode' + '-' + video.id)
      video.pluginData['episodename'] = await storageManager.getData('episodename' + '-' + video.id)

      return video
    }
  })
    registerHook({
    target: 'filter:feed.podcast.channel.create-custom-tags.result',
    handler: async (result, params) => {
      const { videoChannel } = params
      console.log("ðŸš§ðŸš§ðŸš§ðŸš§ initial channel values ðŸš§ðŸš§ðŸš§ðŸš§",params,params.videoChannel.dataValues.Actor,params.videoChannel.dataValues.ownerAccount);
      var channel = params.videoChannel.dataValues.Actor.dataValues.preferredUsername;
      var name =    params.videoChannel.dataValues.name;

      let podreturn = [];
      /* currently handled by lightning plugin
      let channelGuid;
      apiUrl = base + "/plugins/podcast2/router/getchannelguid?channel=" + channel;
      try {
        let guidData = await axios.get(apiUrl);
        if (guidData && guidData.data) {
          console.log("ðŸš§ðŸš§channel guid", guidData.data,apiUrl);
          channelGuid = guidData.data;
        }
      } catch {
        console.log("ðŸš§ðŸš§unable to load channel guid", apiUrl);
      }
      if (channelGuid){
        podreturn.push({
          name: "podcast:guid",
          value: channelGuid,
        });
      }
      console.log("ðŸš§ðŸš§unable to load channel guid", apiUrl);
      */
      let podData;
      try {
        podData = await storageManager.getData("pod-" + channel.replace(/\./g, "-"));
        if (enableDebug){
          console.log("ðŸš§ðŸš§ got poddata ", channel,podData);
        }
      } catch (err) {
        console.log("ðŸš§ðŸš§error getting pod data for ", channel);
      }
      if (podData && podData.email.indexOf("@")>0){
        let blocks =[];
        let newBlock = {};
        newBlock.name = "itunes:owner";
        let iname = {};
        iname.name = "itunes:name";
        iname.value = name;
        blocks.push(iname);
        let iemail={};
        iemail.name = "itunes:email";
        iemail.value =podData.email
        blocks.push(iemail);
        podreturn.push({
          name: "itunes:owner",
          value: blocks,
        });
      }
      if (podData && podData.text && podData.text[0] != "") {
        let ptext = {
          name: "podcast:txt",
          value: podData.text[0]
        }
        podreturn.push(ptext);
      }
      if (podData && podData.feedguid && podData.feedguid !="") {
        let fguid = {
          name: "podcast:guid",
          value: podData.feedguid
        }
        podreturn.push(fguid);  
      }
      if (podData && podData.category && podData.category != "") {
        let category={
          name: "itunes:category",
          attributes: {text: "News"}
        }
        podreturn.push(category);
      }
      if (podData && podData.image && podData.image !="") {
        let image={
          name: "itunes:image",
          attributes: {href: "https://www.peppercarrot.com/0_sources/0ther/framasoft/hi-res/2020-05-21_Peertube-Research_by-David-Revoy.jpg"}
        }
        podreturn.push(image);
      }
      let author = {
        name: "itunes:author",
        value: name
      }
      podreturn.push(author);
      let language = {
        name:"language",
        value: "en"
      }
      podreturn.push(language);
  
      return result.concat(podreturn)
    }
  })
  registerHook({
    target: 'filter:feed.podcast.video.create-custom-tags.result',
    handler: async (result, params) => {      const { video, liveItem } = params
      //console.log("ðŸš§ðŸš§ðŸš§ðŸš§ initial video values ðŸš§ðŸš§ðŸš§ðŸš§",result,params,params.video);
      if (liveItem) {
      }
      var videoUuid = params.video.dataValues.uuid;
      //var videoJSON = await peertubeHelpers.videos.loadByIdOrUUID(videoUuid)
      let customObjects = [];
      let captionApi = base + "/api/v1/videos/" + videoUuid + "/captions";
      let captionResult;
      try {
        captionResult = await axios.get(captionApi);
      } catch (err) {
        console.log("ðŸš§ðŸš§failed requesting transcript data", captionApi,err);
      }
      let captionPath, captionLanguage, captionItem;
      //if (captionResult && captionResult.data && captionResult.data.total > 0) {
      //console.log("ðŸš§ðŸš§\ncaption result", captionResult.data);
      for (var captionEntry in captionResult.data.data) {
        captionPath = base + captionEntry.captionPath
        if (captionEntry.language) {
          captionLanguage = captionEntry.language.id;
        }
        if (captionPath.indexOf("vtt") > 1) {
          type = "text/vtt"
        } else {
          type = "text/plain"
          //fixed = fixed + "\n" + spacer + `<podcast:transcript url="` + captionPath + `" language="` + captionLanguage + `" type="text/plain" rel="captions"/>`;
        }
        captionItem = {
          name: "podcast:transcript",
          attributes: {
            "url": captionPath,
            "language": captionLanguage,
            "type": type,
            "rel": "captions"
          }
        };
        customObjects.push(captionItem);
      }
      var apiCall = base + "/api/v1/videos/" + videoUuid;
      let videoData;
      try {
        videoData = await axios.get(apiCall);
      } catch (err){
        console.log("ðŸš§ðŸš§\n\n\n\n\n\nfailed to pull information for provided video id", apiCall,err);
      }
      if (videoData && videoData.data) {
        if (enableDebug){
          console.log("[pod] video data found");
        }
        let duration = videoData.data.duration;
        let customData = videoData.data.pluginData;
        let filename;
        let smallest = 999999999
        if (enableDebug){
          console.log("[pod] streaming playlists",videoData.data.streamingPlaylists);
        }
        if (videoData.data.streamingPlaylists[0]){
          let videoFiles = videoData.data.streamingPlaylists[0].files;
          if (videoFiles) {
            for (var fileOption of videoFiles) {
              console.log("[pod] file options",fileOption);
              if (fileOption.size < smallest) {
                smallest = fileOption.size;
                filename = fileOption.fileUrl
              }
            }
          }
        } else {
          if (enableDebug){
            console.log("[pod] video streaming file data found",videoData.data);
          }
        }
        var enclosure;
        //console.log("\nðŸš§ðŸš§\n\n\nsmallest??",filename,smallest);
        if (filename) {
          enclosure = {
            name: "audioenclosure",
            attributes: {
              "url": filename,
              type: "video/mp4",
              length: duration
            }
          }
        } 
        if (enclosure) {
          customObjects.push(enclosure);
        }
        console.log("ðŸš§ðŸš§\nplugin data", customData);
        
        if (customData && customData.seasonnode){
          let seasonItem = {
            name: "podcast:season",
            value: await customData.seasonnode.toString()
          };
          if (customData.seasonname){
            seasonItem.attributes={
              "name": customData.seasonname
            }
          }
          customObjects.push(seasonItem);
        }
        
        if (customData && customData.episodenode){
          episodeItem = {
            name: "podcast:episode",
            value: await customData.episodenode.toString()
          };
          if (customData.episodename){
            episodeItem.attributes={
              "display": customData.episodename
            }
          }
          customObjects.push(episodeItem);
        }
        
        if (customData && customData.chapters){
          chaptersItem = {
            name: "podcast:chapters",
            attributes: {
              "url": customData.chapters,
              type: "application/json+chapters"
            }
          };
          customObjects.push(chaptersItem);
        }
       
        if (customData && customData.itemtxt){
         // let txtValue=[].push(customData.itemtxt);
          let txtItem = {
            name: "podcast:txt",
            value: customData.itemtxt
          }
          customObjects.push(txtItem);
        }
        
      }
      console.log("custom objects to add to video",customObjects);
      return result.concat(customObjects);
    }
  })
  
  const router = getRouter();

  router.use('/podcast2', async (req, res) => {
    if (enableDebug) {
      console.log("ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ podcast2 request ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§", req.query);
    }
    if (!enableRss) {
      console.log("ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§ðŸš§RSS disabled");
      return res.status(403).send();
    }
    if (req.query.channel == undefined) {
      console.log("ðŸš§ðŸš§no channel requested", req.query);
      return res.status(404).send();
    }
    let podData
    let podApi = base + "/plugins/podcast2/router/getpoddata?channel=" + req.query.channel;
    try {
      podData = await axios.get(podApi);
    } catch {
      console.log("unable to load PODCAST data",req.query.channel,podApi);
    }
    if (podData) {
      console.log("ðŸš§ðŸš§\n\n\n\n pod data \n", podData.data);
      if (podData.data && podData.data.redirectEnabled){
        //return res.redirect(301, podData.data.redirectUrl);
        res.set('location', podData.data.redirectUrl);
        return res.status(301).send()
      }
    }
    let channel = req.query.channel
    let apiUrl = base + "/api/v1/video-channels/" + channel;
    let channelData;
    try {
      channelData = await axios.get(apiUrl);
    } catch {
      console.log("ðŸš§ðŸš§ðŸš§ðŸš§unable to load channel info", apiUrl);
      return res.status(400).send();
    }
    let smallChannelAvatar, largeChannelAvatar, smallPersonAvatar, largePersonAvatar
    if (channelData && channelData.data && channelData.data.avatars && channelData.data.avatars[1]) {
      smallChannelAvatar = channelData.data.avatars[0].path;
      largeChannelAvatar = channelData.data.avatars[1].path;
    }
    if (channelData && channelData.data && channelData.data.ownerAccount && channelData.data.ownerAccount.avatars && channelData.data.ownerAccount.avatars[1]) {
      smallPersonAvatar = channelData.data.ownerAccount.avatars[0].path;
      largePersonAvatar = channelData.data.ownerAccount.avatars[1].path;
    }
    //console.log("ðŸš§ðŸš§ðŸš§ðŸš§channel info", channelData.data);
    
    let rssUrl = base + "/feeds/podcast/videos.xml?videoChannelId=" + channelData.data.id;
    let rssData;
    try {
      rssData = await axios.get(rssUrl)
    } catch {
      console.log("ðŸš§ðŸš§unable to load rss feed for", channel, rssUrl);
      return res.status(400).send();
    }
    //console.log("ðŸš§ðŸš§loaded rss feed from", rssUrl);
    let channelGuid;
    apiUrl = base + "/plugins/podcast2/router/getchannelguid?channel=" + channel;
    try {
      let guidData = await axios.get(apiUrl);
      if (guidData && guidData.data) {
        //console.log("ðŸš§ðŸš§channel guid", guidData.data);
        channelGuid = guidData.data;
      }
    } catch {
      console.log("ðŸš§ðŸš§unable to load channel guid", apiUrl);
    }
    //TODO figure out how to get info for livechat plugin as well

    let counter = 0;
    let fixed = "";
    let spacer = "";
    let rss = rssData.data;
    let lines = rss.split('\n');
      console.log("ðŸš§ðŸš§\n\n\n\n starting linbe loop \n", lines.length,lines[33]);
    //for (const line of lines) {
    let totalSize = lines.length;
    while (counter<totalSize){
      let line = lines[counter];
      //console.log(`ðŸš§line${counter}:`,line)
      counter++;
      spacer = line.split("<")[0];
      if (line.includes("ToraifÅsu") && podData && podData.data) {

       // if (podData.data.text  && podData.data.text[0] != "") {
       //   line = line + `\n${spacer}<podcast:txt>${podData.data.text[0]}</podcast:txt>`;
       // }
       // if (podData.data.feedguid) {
       //   line = line + `\n${spacer}<podcast:guid>${podData.data.feedguid}</podcast:guid>`;
      //  }
      //  if (podData.data.email){
          //line = line + `\n${spacer}<itunes:owner>`;
          //line = line + `\n${spacer}  <itunes:name>${channelData.data.displayName}</itunes:name>`;
          //line = line + `\n${spacer}  <itunes:email>${podData.data.email}</itunes:email>`;
          //line = line + `\n${spacer}</itunes:owner>`;
          //line = line + `\n${spacer}<language>en</language>`;
          //line = line + `\n${spacer}<itunes:category text="News"/>`;
          //line = line + `\n${spacer}<itunes:image href="https://noagendaassets.com/enc/1686340519.979_pcifeedimage.png"/>`;
       // }
      }
      if (line.includes("<atom:link")) {
        line = `${spacer}<atom:link href="https://${req.get('host')}${req.originalUrl}" rel="self" type="application/rss+xml" />`;
        //line = line + `\n${spacer}<itunes:author>${channelData.data.displayName}</itunes:author>`;
      }
      if (line.includes("itunes:explicit")){
        line = line.replace("no","false");
        line = line.replace("yes","true");
      }
      var customData = {};
      if (line.includes('<guid')) {
        let shortUuid = line.split(">")[1].split("<")[0].split("/")[4]
        try {
          var videoData = await axios.get(base + "/api/v1/videos/" + shortUuid);
          if (videoData && videoData.data) {
            customData = videoData.data.pluginData;
          }
        } catch (err) {
          console.log("ðŸš§ðŸš§ðŸš§ðŸš§hard error trying to get video data for RSS feed", err);
        }
        if (enableDebug) {
          console.log("ðŸš§ðŸš§ðŸš§ðŸš§item plugin data", shortUuid, customData);
        }

      }
      if (line.includes("<enclosure") > 0) {
        continue;
      }
      if (line.includes("audioenclosure") > 0) {
        line = line.replace("audioenclosure", "enclosure");
      }
      if (line.includes(`title="HLS"`) && !line.includes(`length="`)) {
        console.log("fixing length");
        line = line.replace(`title="HLS"`, `title="HLS" length ="69"`);
      }
      if (line.includes(`title="HLS"`) && !line.includes(`type="`)) {
        console.log("fixing type");
        line = line.replace(`title="HLS"`, `title="HLS" type="application/x-mpegURL"`);
      }
      if (line.includes(`title="Audio"`) && !line.includes(`type="`)) {
        console.log("fixing type");
        line = line.replace(`title="Audio"`, `title="Audio" type="audio/mp4"`);
      }
      if (largeChannelAvatar) {
        line = line.replace(smallChannelAvatar, largeChannelAvatar);
      }
      if (largePersonAvatar) {
        line = line.replace(smallPersonAvatar, largePersonAvatar);
      }
      if (podData && podData.data && podData.data.medium) {
        line = line.replace(`<podcast:medium>video</podcast:medium>`, `<podcast:medium>${podData.data.medium}</podcast:medium>`);
      }
      if (counter > 1) {
        fixed = fixed + '\n' + line;
      } else {
        fixed = line;
      }
    }
    res.setHeader('content-type', 'application/rss+xml');
    console.log("ðŸš§ðŸš§\n\n\n\n ending line loop \n",fixed.length);
    return  res.status(200).send(fixed);
    
  })
  router.use('/dirtyhack', async (req, res) => {
    console.log("ðŸš§ðŸš§ðŸš§ðŸš§ dirty hack",req.query,req.body);
    let dirtyHack;
    if (req.query.cp){
      console.log("ðŸš§ðŸš§ðŸš§ðŸš§ clearing patronage paid days");
      let subscriptions = await storageManager.getData('subscriptions');
      let list = [];
      if (subscriptions){
        for (var sub of subscriptions){
          sub.paiddays=0;
        }
        storageManager.storeData("subscriptions", subscriptions);
        return res.status(200).send(subscriptions);
      }
    }
    let feed;
    if (req.query.clone){
      try {
        feed = await parser.parseURL(req.query.clone);
      } catch {
        console.log("error loading rss feed",req.query.clone);
        return res.status(420).send("hard error loading feed: "+req.query.clone);
      }
      if (!feed){
        console.log("error loading rss feed",req.query.clone);
        return res.status(420).send("error loading feed : "+req.query.clone);  
      }
      let header = req.body.bear;
      //TODO funding -> support
      let fixedName;
      if (feed.title){
        fixedName = feed.title.replace(/\W/g, '').toLowerCase();
        if (fixedName.length>25){
          fixedName =fixedName.slice(0,25);
        }
      } else {
        console.log("ðŸš§ðŸš§ðŸš§ðŸš§ Unable to find channel name in provided feed", req.query.clone);
        return res.status(420).send("No Channel title found in stream:"+req.query.clone);
      }
      let getChannelApi = base+"/api/v1/video-channels/"+fixedName;
      let channelData;
      let channelId;
      let description
      let imageUrl;
      let displayName = feed.title.replace(/[^\w\s]/gi, '');
      if (feed.description){
        description = feed.description.replace(/[^\w\s]/gi, '')
        if (description.length>990){
          description = feed.description.slice(0,990);
        }
      }
       console.log("ðŸš§ðŸš§ new channel info",fixedName.length,displayName.length,description.length);
      try {
        channelData = await axios.get(getChannelApi);
      } catch (err) {
        console.log(`ðŸš§ðŸš§ no channel ${getChannelApi} found`);
      }
      if (channelData && channelData.data && channelData.data.id){
        channelId = channelData.data.id
        console.log("ðŸš§ðŸš§ got existing channel info ",channelData.data);
      } else {

        let newChannel ={
          "displayName": displayName,
          "name": fixedName,
          "description": description,
        }
        console.log("new channel object",newChannel,header);
        let result = await createChannel(newChannel,header);
        // console.log("ðŸš§ðŸš§ created channel",result.data, result.data.id, result.data.videoChannel.id);
        if (result && result.data.videoChannel.id){
          channelId = result.data.videoChannel.id;
        }
      }
      if (!channelId){
        console.log("ðŸš§ðŸš§ no channelId, unable to proceed");
        return res.status(420).send("No Channel ID found or created for :"+req.query.clone);
      }
      if (feed.image || feed.itunes){
        if (feed.image){
          imageUrl = feed.image.url;
          console.log("feed image",feed.image);
        }
        console.log("ðŸš§ðŸš§first image url",imageUrl);
        if (!imageUrl && feed.image && feed.image.href){
          imageUrl = feed.image.href;
        }
        console.log("ðŸš§ðŸš§2nd image url",imageUrl);
        if (!imageUrl && feed.image){
          imageUrl = feed.image;
        }
        console.log("ðŸš§ðŸš§third image url",imageUrl);
        if (!imageUrl && feed.itunes && feed.itunes.image){
          imageUrl = feed.itunes.image.url;
          console.log("feed itunes",feed.itunes);
        }
         console.log("ðŸš§ðŸš§ fourth url",imageUrl);
        if (!imageUrl && feed.itunes && feed.itunes.image){
          imageUrl = feed.itunes.image;
        } 
        if (!imageUrl){
          console.log("ðŸš§ðŸš§ no  image url",feed.itunes);
        }
        console.log("ðŸš§ðŸš§final image url",imageUrl);
        imageUrl = `https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Sepia.svg/180px-Sepia.svg.png`
        let image = await getImage(imageUrl,fixedName,header);
        return;
        var form = new FormData();
        let avatarUrl = base+`/api/v1/video-channels/${fixedName}/avatar/pick`;
        await form.append('avatarfile', request(imageUrl));
        console.log("form",form);
        await axios.post(avatarUrl,
            form.getBuffer(),
            { headers: header }
          )

        form.submit(avatarUrl, function(err, res) {
          // res â€“ response object (http.IncomingMessage)  //
          res.resume();
          console.log("res");
        });
        console.log("ðŸš§ðŸš§ image string",form,avatarUrl);
        return;
        if (imageUrl){
          let avatarBody = { data: {avatarfile: imageString}};
          let avatarUrl = base+`/api/v1/video-channels/${fixedName}/avatar/pick`;
          console.log("ðŸš§ðŸš§ Setting channel avatar",avatarUrl,avatarBody);
          try {
            await axios.post(avatarUrl,avatarBody,{ headers: header });
          } catch (err){
            console.log("ðŸš§ðŸš§ hard error setting avatar",avatarUrl,avatarBody);
          }
        }
      } else {
        console.log("ðŸš§ðŸš§ no itunes image found",feed);
      }
      console.log("ðŸš§ðŸš§ Starting to process rss stream items",channelId,fixedName,feed.title);     
      dirtyHack = "";
      for (var item of feed.items){
        dirtyHack=dirtyHack+ await rssJsonToApiJson(item);
        item.channelId = channelId;
        let importBody = await rssJsonToApiJson(item);
        console.log("ðŸš§ðŸš§ json", item, importBody);
        
        let importApi = base+"/api/v1/videos/imports";
        try {
          let result = await axios.post(importApi,importBody,{ headers: header });
        } catch (err){
          console.log("ðŸš§ðŸš§ hard error importing podcast",importApi,importBody,header,err);
        }
      };
    }
    //doSubscriptions();
    return res.status(200).send(dirtyHack);
  });
  router.use('/getfeedid', async (req, res) => {
    if (enableDebug) {
      console.log("ðŸš§ðŸš§getting feed id", req.query);
    }
    let channel = req.query.channel;
    if (!channel) {
      return res.status(420).send("no channel in feed id request");
    }
    let feed;
    let parts = channel.split('@');
    if (parts.length > 1) {
      let feedApi = "https://" + parts[1] + "/plugins/podcast2/router/getfeedid?channel=" + parts[0];
      try {
        feed = await axios.get(feedApi);
      } catch {
        console.log("ðŸš§ðŸš§hard error getting feed id for ", channel, "from", parts[1], feedApi);
      }
      if (feed && feed.data) {
        //console.log("ðŸš§ðŸš§ returning", feed.data, "for", channel,feed.data.toString());
        return res.status(200).send(feed.data.toString());
      }
      return res.status(420).send("remote channel returned no feed id");
    }
    if (channel) {
      try {
        feed = await storageManager.getData("podcast" + "-" + channel)
      } catch (err) {
        console.log("ðŸš§ðŸš§error getting feedid", channel);
      }
    }
    //console.log("ðŸš§ðŸš§ feed", feed);
    if (feed) {
      return res.status(200).send(feed.toString());
    } else {
      return res.status(400).send("no feed id found for requested channel");
    }
  })
  router.use('/setfeedid', async (req, res) => {
    if (enableDebug) {
      console.log("ðŸš§ðŸš§setting feed id", req.query);
    }
    let channel = req.query.channel;
    let feedID = req.query.feedid;
    if (channel) {
      try {
        await storageManager.storeData("podcast" + "-" + channel, feedID);
        return res.status(200).send();
      } catch (err) {
        console.log("ðŸš§ðŸš§ error storing feedid", channel, feedID);
        return res.status(400).send();
      }
    }
  })
  router.use('/getitemid', async (req, res) => {
    if (enableDebug) {
      console.log("ðŸš§ðŸš§getting item id", req.query);
    }
    let uuid = req.query.uuid;
    let item;
    if (uuid) {
      try {
        item = await storageManager.getData("podcast" + "-" + uuid);
      } catch (err) {
        console.log("ðŸš§ðŸš§ error getting stored itemid", uuid);
      }
    }
    if (item) {
      return res.status(200).send(item.toString());
    } else {
      var apiCall = base + "/api/v1/videos/" + uuid;
      let videoData;
      try {
        videoData = await axios.get(apiCall);
      } catch {
        console.log("ðŸš§ðŸš§failed to pull information for provided video id", apiCall);
      }
      if (videoData) {
        let videoHost = videoData.data.channel.host
        if ("https://" + videoHost != base) {
          let hostApi = "https://" + videoHost + "/plugins/podcast2/router/getitemid?uuid=" + uuid;
          let hostItemId;
          try {
            hostItemId = await axios.get(hostApi);
          } catch {
            console.log("ðŸš§ðŸš§failed to pull item ID from video host", hostApi);
          }
          if (hostItemId) {
            try {
              await storageManager.storeData("podcast" + "-" + uuid, hostItemId);
            } catch {
              console.log("ðŸš§ðŸš§failed to store item ID from host", uuid, hostItemId);
            }
            return res.status(200).send(hostItemId.data.toString());
          } else {
            console.log("ðŸš§ðŸš§ No id provided by hosting instance");
          }
        }
        let channel = videoData.data.channel.name;
        let feedApi = base + "/plugins/podcast2/router/getfeedid?channel=" + channel;
        try {
          feedId = await axios.get(feedApi);
        } catch {
          console.log("ðŸš§ðŸš§ error when tring to get feed id ", feedApi);
          return res.status(404).send();
        }

      }
      console.log("ðŸš§ðŸš§no videodata available", apiCall);
      return res.status(400).send();
    }
  })
  router.use('/setitemid', async (req, res) => {
    if (enableDebug) {
      console.log("ðŸš§ðŸš§setting item id", req.query.uuid);
    }
    let uuid = req.query.uuid;
    let itemID = req.query.itemid;
    if (uuid) {
      try {
        await storageManager.storeData("podcast" + "-" + uuid, itemID);
        return res.sendStatus(200);
      } catch (err) {
        console.log("ðŸš§ðŸš§error setting item id", uuid, itemID);
        return res.sendStatus(400).send();
      }
    }
  })
  router.use('/getchannelguid', async (req, res) => {
    if (enableDebug) {
      console.log("ðŸš§ðŸš§getting channel guid", req.query);
    }
    let host,channelOnly;
    let channel = req.query.channel;
    parts = channel.split("@");
    if (parts.length>1){
      host = parts[1];
      channelOnly = parts[0];
    }
    let channelGuid;
    if (channel) {
      try {
        channelGuid = await storageManager.getData("channelguid" + "-" + channel)
      } catch (err) {
        console.log("ðŸš§ðŸš§ error getting channel guid", channel);
        return res.status(400).send();
      }
    }
    if (!channelGuid && host){
      apiUrl = `https://${host}/plugins/podcast2/router/getchannelguid?channel=${channelOnly}`;
      try {
        console.log("ðŸš§ðŸš§ stuff",base,host,apiUrl);
        let guidData = await axios.get(apiUrl);
        if (guidData && guidData.data) {
          //console.log("ðŸš§ðŸš§channel guid", guidData.data);
          channelGuid = guidData.data;
        }
      } catch {
        console.log("ðŸš§ðŸš§unable to load channel guid", apiUrl);
      }
    }
    if (channelGuid) {
      return res.status(200).send(channelGuid);
    } else {
      //TODO properly create guid
      //let guidResolverUrl = "https://guid.peertube.support/"  
      let rssUrl;
      if (channelOnly){
        rssUrl= await getRss(channelOnly);
      } else {
        rssUrl = await getRss(channel);
      }
      channelGuid = await v5('url',rssUrl);
      if (channelGuid) {
        try {
          await storageManager.storeData("channelguid" + "-" + channel, channelGuid);
        } catch {
          console.log("ðŸš§ðŸš§failed to store channel guid", channel, channelGuid);
        }
        return res.status(200).send(channelGuid);
      } else {
        console.log("ðŸš§ðŸš§ error attempting to generate channel guiid",channel);
        return res.status(400).send();
      }
    }
  })
  router.use('/getpoddata', async (req, res) => {
    if (enableDebug) {
      console.log("ðŸš§ðŸš§getting pod data", req.query);
    }
    let channel = req.query.channel;
    if (!channel) {
      console.log("ðŸš§ðŸš§ no channel in query", channel, req.query);
      return res.status(400).send("ðŸš§ðŸš§ no channel value in request " + req.query);
    }
    let parts = channel.split('@');
    let remotePodData;
    if (parts.length > 1) {
      let remotePodApi = "https://" + parts[1] + "/plugins/podcast2/router/getpoddata?channel=" + parts[0];
      try {
        remotePodData = await axios.get(remotePodApi);
      } catch (err) {
        console.log("ðŸš§ðŸš§hard error getting custom remote pod data for ", channel, "from", parts[1], remotePodApi, err);
        return res.status(400).send("ðŸš§ðŸš§hard error getting custom remote pod data for " + channel + " from " + parts[1] + " using " + remotePodApi + " error " + err);
      }
      if (remotePodData) {
        //console.log("ðŸš§ðŸš§ returning", customChat.toString(), "for", channel);
        return res.status(200).send(remotePodData.data);
      }
      console.log("ðŸš§ðŸš§ no remote pod data found for", channel);
      return res.status(404).send("ðŸš§ðŸš§ no podcast data for " + channel + " on remote system");
    }
    let podData;
    try {
      podData = await storageManager.getData("pod-" + channel.replace(/\./g, "-"));
    } catch (err) {
      console.log("ðŸš§ðŸš§error getting pod data for ", channel);
      return res.status(404).send("ðŸš§ðŸš§ no podcast data for " + req.query.channel + err);
    }
    if (podData) {
      return res.status(200).send(podData);
    } else {
      console.log("ðŸš§ðŸš§ no pod data found for", channel);
      return res.status(404).send("ðŸš§ðŸš§ no pod data found for " + channel);
    }
  })
  router.use('/setpoddata', async (req, res) => {
    if (enableDebug) {
      console.log("ðŸš§ðŸš§setting podcast data", req.query, req.body);
    }
    //TODO verify authorized user is actual owner of room
    let user = await peertubeHelpers.user.getAuthUser(res);
    if (user && user.dataValues && req.body) {
      let userName = user.dataValues.username;
      if (enableDebug) {
        console.log("ðŸš§ðŸš§ðŸš§ got authorized peertube user to set pod data ", user.dataValues.username);
      }
      if (enableDebug) {
        console.log("ðŸš§ðŸš§ðŸš§ðŸš§ user", userName);
      }
      let channel = req.body.channel;
      storageManager.storeData("pod-" + channel.replace(/\./g, "-"), req.body);
      pingPI(channel);
      return res.status(200).send();
    }
    return res.status(420).send();
  })
  async function pingPI(pingChannel) {
    let feedApi = base + "/plugins/podcast2/router/getfeedid?channel=" + pingChannel;
    let feedId;
    try {
      feedId = await axios.get(feedApi);
      let pingResult;
      if (feedId) {
        pingResult = await axios.get("https://api.podcastindex.org/api/1.0/hub/pubnotify?id=" + feedId.data);
      }
      if (pingResult && pingResult.data) {
        return (pingResult.data);
      }
    } catch {
      console.log("ðŸš§ðŸš§hard error when trying ping podcast index ", feedId, feedApi);
    }
  }
  async function getRss(channel){
    let apiUrl = base + "/api/v1/video-channels/" + channel;
    let channelData;
    try {
      channelData = await axios.get(apiUrl);
    } catch {
      console.log("ðŸš§ðŸš§ðŸš§ðŸš§unable to load channel info", apiUrl);
      return ;
    }
    let rssUrl = base + "/feeds/podcast/videos.xml?videoChannelId="+channelData
    return rssUrl;
  }
  async function getConfigPanel(splitInfo, channel) {
    let feedID = await getFeedID(channel);
    if (debugEnabled) {
      console.log("ðŸš§getting config panel", splitInfo, feedID, channel);
    }
    let html = `<br><label _ngcontent-msy-c247="" for="Wallet">Lightning Splits</label><br>`
    if (splitInfo && (keysendEnabled || lnurlEnabled)) {
      if (splitInfo.length > 0) {
        html = html + "<table><th>Split %</th><th><center>Lighting Address</center></th><th>Address Type</th></tr>";
        for (var split in splitInfo) {
          let displayName = splitInfo[split].name;
          if (!displayName) {
            displayName = splitInfo[split].address;
          }
          html = html + "<tr><td>" + splitInfo[split].split + "</td><td>" + displayName + "</td>";
          if (splitInfo[split].keysend) {
            html = html + `<td>Keysend</td>`;
          } else if (splitInfo[split].customKeysend) {
            html = html + `<td>Node</td>`;
          } else if (splitInfo[split].lnurl) {
            html = html + "<td>LNURL Pay</td>";
          } else {
            html = html + "<td>unknown</td>"
          }
          if (!splitInfo[split].fee) {
            html = html + `<td><div class="peertube-button orange-button ng-star-inserted" slot="` + split + `" id="edit-` + split + `">edit</div></td>`;
            //html = html + `<td><button class="peertube-button orange-button ng-star-inserted" >edit</button></td>`;
          }
          html = html + "</tr>";
        }
        html = html + "</table>";
      }
      html = html + `<button type="button" id="add-split" class="peertube-button orange-button ng-star-inserted">Add Split</button>`
    } else {
      html = html + `<button type="button" id="create-split" class="peertube-button orange-button ng-star-inserted">Add Lightning Address</button>`

    }
    if (rssEnabled) {
      html = html + "<hr>"
      html = html + `<button type="button" id="rss-settings" name="ress-settings" class="peertube-button orange-button ng-star-inserted">Podcasting 2.0 RSS settings</button>`;
    }


    html = html + "<hr>"

    //html = html + "<br>podcast 2.0 RSS feed URL: " + rssFeedUrl;
    const panel = document.createElement('div');
    panel.setAttribute('class', 'lightning-button');
    panel.setAttribute('sandbox', 'allow-same-origin allow-scripts allow-popups allow-forms')
    panel.innerHTML = html;
    return panel;
  }
  async function getImage(imageUrl,channel,header){
    console.log("ðŸš§oh boy, this again",imageUrl,channel,header);
    if (!imageUrl){
      return undefined;
    }
    var fileName = channel + "-avatar.jpg";
    var downloader = new Downloader({
      url: imageUrl,
      directory: basePath + "/avatars",
      fileName: fileName,
      cloneFiles: false
    })
    try {
      var avatarDownloadResult = await downloader.download();
      console.log('ðŸš§downloaded', avatarDownloadResult);
    } catch (error) {
      console.log('ðŸš§Download failed', fileName, error)
    }
    console.log("ðŸš§avatar  downloaded", avatarDownloadResult);
    form = new FormData;
    form.append( 'avatarfile', fs.createReadStream(basePath + '/avatars/'+fileName, {filename: 'bar.jpg', contentType: 'image/jpeg'} ));
    const formHeaders = form.getHeaders();
    console.log("ðŸš§ form headers",formHeaders);
    let mergeheaders = {
      ...header,
      ...formHeaders,
    }
    console.log("ðŸš§ form headers2",formHeaders);
    let avatarUrl = base+`/api/v1/video-channels/${channel}/avatar/pick`;
    await axios.post(avatarUrl, form, {
      headers: {
        ...mergeheaders,
      },
    })
      .then(response => response)
      .catch(error => error)
      return ;
    /*

    let dataString = fs.createReadStream(basePath + "/avatars/" + fileName)
    //return dataString;
    let gorf = new FormData()
    gorf.append('avatarfile', dataString)
    console.log("ðŸš§ðŸš§ fs on downloaded file version",gorf);
    * /
    let data;
    try {
      data = await imageDataURI.encodeFromURL(imageUrl);
    } catch (err) {
      console.log("ðŸš§ðŸš§ Hard error getting image from url",imageUrl);
    }
    let gank = new FormData()
    gank.append('avatarfile',data);
    gank.append('filename',"eatme.jpg");
    console.log("imageDataURI version",gank, "\n\n\n\n\n\n\n",gank._streams[0]);
    return gank._streams[0];
    
    try {
      request.defaults({ encoding: null });
      request.get('imageUrl', function (error, response, body) {
          if (!error && response.statusCode == 200) {
              data = "data:" + response.headers["content-type"] + ";base64," + Buffer.from(body).toString('base64');
              console.log("ðŸš§ðŸš§ image string",data,new FormData().append('avatarfile', data));
          }
      });
    } catch {
      console.log("ðŸš§ðŸš§ stuff done blown up");  
    }
    let image = await axios.get(imageUrl, {responseType: 'arraybuffer'});
    let returnedB64 = Buffer.from(image.data).toString('base64');
    let geek = new FormData()
    geek.append('avatarfile', returnedB64);
    console.log("ðŸš§ðŸš§ axios get version ", geek,);
  */
  var form = new FormData();

//form.append('my_field', 'my value');
//form.append('my_buffer', new Buffer(10));
form.append('avatarfile', request(imageUrl));
form.submit('http://example.org/', function(err, res) {
  // res â€“ response object (http.IncomingMessage)  //
  res.resume();
  console.log("res");
});
  }
  async function rssJsonToApiJson(rss){
   if (!rss){
    console.log("ðŸš§ðŸš§ no rss");
    return
   }
   let api = {}
   if (!rss.channelId || !rss.title || !rss.enclosure){
    return false;
   }
   api.language = "en";
   api.privacy = 1;
   api.channelId = rss.channelId;
   api.name = rss.title;
   if (api.name.length>119){
    api.name = api.name.slice(0,119);
   }
   if (rss.enclosure){
     api.targetUrl = rss.enclosure.url;
   }
   if (rss.category){
    console.log("TODO category conversion is hard, check rss2peertube for help");
   }
   if (rss.content){
    if (rss.content.length>990){rss.content=rss.content.slice(0,990)}
    api.description=rss.content;
   }
   api.nsfw = false;
   if ( rss && rss.itunes && rss.itunes.explicit && rss.itunes.explicit.toLowerCase() == "yes"){
    api.nsfw=true;
   }
   if (rss.isoDate){
    api.originallyPublishedAt = rss.isoDate;
   }
   if (rss.value){
    api.support = rss.value;
   }
   if (rss.itunes && rss.itunes.image){
    let videoUrl;
    if (rss.itunes.image.url){
      videoUrl=rss.itunes.image.url;
    } else {
      if (rss.itunes.image.href){
        videoUrl =rss.itunes.image.href;
      }
    }
    if (videoUrl){
      api.thumbnailfile=await getImage(videoUrl);
    }
     
  }
   return api;
  }
  async function createChannel(channel,header ){
    console.log("ðŸš§ðŸš§ creating channel",channel,header);
    let url = base+"/api/v1/video-channels";
    try {
      return await axios.post(url,channel,{ headers: header });
    } catch (err){
      return (err);
    }
  }
  async function getPeerTubeToken(username, password) {
    var clientTokenPath = base + "/api/v1/oauth-clients/local";
    var userTokenPath = base + "/api/v1/users/token";
    try {
      let clientResult = await axios.get(clientTokenPath);
      if (clientResult && clientResult.data) {
        let peertubeClientId = clientResult.data.client_id;
        let clientSecret = clientResult.data.client_secret;
        var data = new URLSearchParams();
        data.append('client_id', peertubeClientId);
        data.append('client_secret', clientSecret);
        data.append('grant_type', 'password');
        data.append('response_type', 'code');
        data.append('username', username);
        data.append('password', password);
        var postData = data.toString();
        let tokenresponse = await axios.post(userTokenPath, data);
        console.log("token request respoonse", tokenresponse.data);
        bearerToken = tokenresponse.data.access_token;
        return (bearerToken);
      } else {
        console.log("failed to get client token");
      }
    } catch (error) {
      console.log("error in get token", ptuser, ptpassword, ptApi);
      return (-1);
    }
    return;
  }
}
async function unregister () {
  return
}

module.exports = {
  register,
  unregister
}
